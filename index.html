<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <!-- Yandex Games SDK -->
    <script src="https://yandex.ru/games/sdk/v2"></script>
    <title>–ö–∏–±–µ—Ä –ö–æ—Ç: –ü–æ–ª—ë—Ç</title>
    <style>
        /* --- –ë–ê–ó–û–í–´–ï –ù–ê–°–¢–†–û–ô–ö–ò --- */
        body {
            margin: 0;
            padding: 0;
            width: 100vw;
            /* –ò—Å–ø–æ–ª—å–∑—É–µ–º dvh –¥–ª—è –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–π —Ä–∞–±–æ—Ç—ã —Å –∞–¥—Ä–µ—Å–Ω–æ–π —Å—Ç—Ä–æ–∫–æ–π –º–æ–±–∏–ª—å–Ω—ã—Ö –±—Ä–∞—É–∑–µ—Ä–æ–≤ */
            height: 100dvh; 
            /* –¶–≤–µ—Ç —Ñ–æ–Ω–∞ —Å–æ–≤–ø–∞–¥–∞–µ—Ç —Å –∏–≥—Ä–æ–π, —á—Ç–æ–±—ã —É–±—Ä–∞—Ç—å –±–µ–ª—ã–µ –ø–æ–ª–æ—Å—ã */
            background: #0d001a; 
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            font-family: 'Courier New', Courier, monospace;
            
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            -webkit-touch-callout: none;
            touch-action: none;
        }

        /* --- –ò–ì–†–û–í–û–ô –ö–û–ù–¢–ï–ô–ù–ï–† --- */
        #game-wrapper {
            position: relative;
            /* –ê–¥–∞–ø—Ç–∏–≤–Ω–∞—è —à–∏—Ä–∏–Ω–∞ –∏ –≤—ã—Å–æ—Ç–∞ */
            width: 100%; 
            height: 100%;
            /* –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ —à–∏—Ä–∏–Ω—ã –¥–ª—è –ü–ö, —á—Ç–æ–±—ã —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –ø—Ä–æ–ø–æ—Ä—Ü–∏–∏ —Ç–µ–ª–µ—Ñ–æ–Ω–∞ */
            max-width: 60vh; 
            box-shadow: 0 0 100px rgba(0, 255, 255, 0.2);
            overflow: hidden;
            background-color: #000;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            /* –í–∞–∂–Ω–æ: contain —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç –ø—Ä–æ–ø–æ—Ä—Ü–∏–∏ –∫–∞–Ω–≤–∞—Å–∞ –≤–Ω—É—Ç—Ä–∏ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞ */
            object-fit: contain; 
            background: linear-gradient(180deg, #0d001a 0%, #000033 100%);
        }

        /* --- UI –°–õ–û–ô --- */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            z-index: 10;
        }

        /* --- –í–ï–†–•–ù–Ø–Ø –ü–ê–ù–ï–õ–¨ --- */
        #top-bar {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            gap: 15px;
            pointer-events: auto;
            z-index: 100;
        }

        .icon-btn {
            width: 50px;
            height: 50px;
            background: rgba(0, 20, 40, 0.8);
            border: 2px solid #0ff;
            color: #0ff;
            font-size: 24px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
            border-radius: 8px;
            transition: all 0.2s;
        }

        .icon-btn:active {
            background: #0ff;
            color: #000;
            transform: scale(0.9);
        }

        .icon-btn.muted {
            border-color: #ff0055;
            color: #ff0055;
            box-shadow: 0 0 10px rgba(255, 0, 85, 0.3);
        }

        /* –î–æ–ø. —Å—Ç–∏–ª–∏ –¥–ª—è –∫–Ω–æ–ø–∫–∏ –Ω–∞—Å—Ç—Ä–æ–µ–∫ –Ω–∞ –≥–ª–∞–≤–Ω–æ–º —ç–∫—Ä–∞–Ω–µ */
        #btn-settings-open {
            position: absolute;
            top: 20px;
            left: 20px;
            pointer-events: auto;
            z-index: 100;
        }

        /* --- –≠–ö–†–ê–ù–´ --- */
        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(5px);
            pointer-events: auto;
            transition: opacity 0.3s;
            z-index: 15;
            gap: 20px; 
        }

        .screen.hidden {
            opacity: 0;
            pointer-events: none;
        }

        /* --- –ö–ê–†–¢–û–ß–ù–ê–Ø –°–ò–°–¢–ï–ú–ê --- */
        .card {
            background: rgba(0, 0, 0, 0.85);
            border: 1px solid #0ff;
            border-radius: 15px;
            padding: 30px 40px;
            display: flex;
            flex-direction: column;
            align-items: center;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.15);
            min-width: 60%;
            box-sizing: border-box;
            text-align: center;
            margin-bottom: 10px;
        }

        .card-red {
            border-color: #ff0055;
            box-shadow: 0 0 20px rgba(255, 0, 85, 0.15);
        }

        /* --- –¢–ò–ü–û–ì–†–ê–§–ò–ö–ê --- */
        .game-title {
            color: #0ff;
            font-size: 6vh; /* –£–º–µ–Ω—å—à–µ–Ω–æ —Å 8vh, —á—Ç–æ–±—ã –≤–º–µ—Å—Ç–∏—Ç—å –ø–æ–¥–∑–∞–≥–æ–ª–æ–≤–æ–∫ */
            margin: 0 0 30px 0; /* –ù–µ–º–Ω–æ–≥–æ —É–º–µ–Ω—å—à–µ–Ω –æ—Ç—Å—Ç—É–ø */
            text-shadow: 0 0 10px #0ff, 0 0 20px #0ff;
            text-align: center;
            line-height: 1.1;
        }

        .mission-failed {
            color: #ff0055;
            font-size: 5vh;
            margin: 0 0 20px 0;
            text-shadow: 0 0 10px #ff0055;
            text-align: center;
            font-weight: bold;
            line-height: 1.1;
        }

        .label {
            color: #aaa;
            font-size: 1.8vh;
            letter-spacing: 2px;
            margin-bottom: 5px;
            text-transform: uppercase;
        }

        .val-text {
            color: #0ff; 
            font-size: 2vh; 
            margin-top: 5px;
        }

        .score-big {
            font-size: 8vh;
            color: #fff;
            font-weight: bold;
            margin: 0 0 15px 0;
            text-shadow: 0 0 10px rgba(255,255,255,0.5);
            line-height: 1;
        }

        .best-score-container {
            background: rgba(255, 255, 255, 0.1);
            padding: 8px 15px;
            border-radius: 20px;
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .best-label {
            color: #0ff;
            font-size: 2vh;
            font-weight: bold;
        }

        .best-value {
            color: #fff;
            font-size: 2vh;
        }

        .title-paused {
            color: #FFFF00;
            text-shadow: 0 0 10px #FFFF00;
            font-size: 6vh;
            margin-bottom: 20px;
            text-align: center;
        }

        /* --- –ö–ù–û–ü–ö–ò --- */
        .btn {
            background: rgba(0, 20, 40, 0.9);
            border: 2px solid #0ff;
            color: #0ff;
            padding: 20px 30px; /* –£–º–µ–Ω—å—à–∏–ª –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ã–π –ø–∞–¥–¥–∏–Ω–≥ –¥–ª—è –º–æ–±–∏–ª–æ–∫ */
            font-family: 'Courier New', Courier, monospace;
            font-size: 3vh;
            font-weight: bold;
            text-transform: uppercase;
            cursor: pointer;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
            border-radius: 5px;
            transition: all 0.2s;
            /* –£–¥–∞–ª–µ–Ω—ã min-width –¥–ª—è .btn, —á—Ç–æ–±—ã –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å .btn-wide */
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .btn:active {
            background: #0ff;
            color: #000;
            box-shadow: 0 0 30px #0ff;
            transform: scale(0.96);
        }

        /* –°—Ç–∏–ª–∏ –¥–ª—è —à–∏—Ä–æ–∫–∏—Ö –∫–Ω–æ–ø–æ–∫ –≤ –º–µ–Ω—é –ø—Ä–æ–∏–≥—Ä—ã—à–∞ */
        .gameover-buttons {
            display: flex;
            flex-direction: column;
            width: 100%;
            gap: 15px;
            align-items: center;
            margin-top: 10px;
        }

        .btn-wide {
            width: 80%;
            max-width: 350px;
            height: 60px; /* –§–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –≤—ã—Å–æ—Ç–∞ –¥–ª—è –µ–¥–∏–Ω–æ–æ–±—Ä–∞–∑–∏—è */
            padding: 0;   /* –£–±–∏—Ä–∞–µ–º –ø–∞–¥–¥–∏–Ω–≥, –∫–æ–Ω—Ç–µ–Ω—Ç —Ü–µ–Ω—Ç—Ä–∏—Ä—É–µ—Ç—Å—è —Ñ–ª–µ–∫—Å–æ–º */
            font-size: 2.5vh;
        }

        /* –ö–æ–º–ø–∞–∫—Ç–Ω—ã–µ –∫–Ω–æ–ø–∫–∏ –¥–ª—è –º–∞–≥–∞–∑–∏–Ω–∞ */
        .btn-shop-compact {
            width: 80%;
            max-width: 300px;
            min-height: 50px; /* –£–º–µ–Ω—å—à–µ–Ω–Ω–∞—è –≤—ã—Å–æ—Ç–∞ */
            padding: 5px 15px;
            font-size: 2.5vh;
            margin: 0; /* –£–±–∏—Ä–∞–µ–º –æ—Ç—Å—Ç—É–ø—ã, –∏—Å–ø–æ–ª—å–∑—É–µ–º gap –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞ */
        }

        /* –°—Ç–∏–ª—å –¥–ª—è —Å—É—Ñ—Ñ–∏–∫—Å–∞ (–†–µ–∫–ª–∞–º–∞) */
        .ad-hint {
            font-size: 0.7em;
            opacity: 0.6;
            margin-left: 8px;
            font-weight: normal;
        }

        .btn-restart {
            border-color: #ff0055;
            color: #ff0055;
            box-shadow: 0 0 15px rgba(255, 0, 85, 0.3);
        }
        .btn-restart:active {
            background: #ff0055;
            color: #000;
            box-shadow: 0 0 30px #ff0055;
        }
        
        .btn-revive {
            border-color: #00ff00;
            color: #00ff00;
            box-shadow: 0 0 15px rgba(0, 255, 0, 0.3);
        }
        .btn-revive:active {
            background: #00ff00;
            color: #000;
            box-shadow: 0 0 30px #00ff00;
        }

        .btn-resume {
            border-color: #FFFF00;
            color: #FFFF00;
            box-shadow: 0 0 15px rgba(255, 255, 0, 0.3);
            min-width: 240px;
            min-height: 70px;
        }
        .btn-resume:active {
            background: #FFFF00;
            color: #000;
        }

        .btn-shop {
            border-color: #f0f;
            color: #f0f;
            box-shadow: 0 0 15px rgba(255, 0, 255, 0.3);
            margin-top: 10px;
            min-width: 240px;
            min-height: 70px;
        }
        .btn-shop:active {
            background: #f0f;
            color: #000;
        }

        .btn-menu-secondary {
            border: 1px solid #aaa;
            color: #aaa;
            background: rgba(0,0,0,0.5);
            box-shadow: none;
            /* –†–∞–∑–º–µ—Ä—ã –¥–ª—è —ç—Ç–æ–π –∫–Ω–æ–ø–∫–∏ –∑–∞–¥–∞—é—Ç—Å—è —á–µ—Ä–µ–∑ .btn-wide –µ—Å–ª–∏ –æ–Ω–∞ –≤ –±–ª–æ–∫–µ gameover */
        }
        .btn-menu-secondary:active {
            background: #aaa;
            color: #000;
        }

        /* --- SHOP STYLES --- */
        /* –°–ø–µ—Ü–∏–∞–ª—å–Ω—ã–π —Å—Ç–∏–ª—å –¥–ª—è —ç–∫—Ä–∞–Ω–∞ –º–∞–≥–∞–∑–∏–Ω–∞ –¥–ª—è –ø–ª–æ—Ç–Ω–æ–π –≤–µ—Ä—Å—Ç–∫–∏ */
        #shop-screen {
            gap: 10px; /* –£–º–µ–Ω—å—à–µ–Ω–Ω—ã–π –æ—Ç—Å—Ç—É–ø –º–µ–∂–¥—É —ç–ª–µ–º–µ–Ω—Ç–∞–º–∏ */
            justify-content: center;
        }

        .shop-container {
            display: flex;
            align-items: center;
            gap: 15px;
            margin: 10px 0; /* –û—Ç—Å—Ç—É–ø—ã —Å–≤–µ—Ä—Ö—É –∏ —Å–Ω–∏–∑—É */
        }
        .preview-box {
            width: 200px;
            height: 250px;
            border: 2px solid #555;
            background: rgba(0,0,0,0.8);
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: space-between;
            padding: 20px;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }
        .arrow-btn {
            background: none;
            border: none;
            color: #fff;
            font-size: 40px;
            cursor: pointer;
            opacity: 0.7;
            transition: 0.2s;
        }
        .arrow-btn:active {
            transform: scale(0.8);
            color: #0ff;
        }
        .skin-name {
            color: #fff;
            font-size: 2vh;
            margin-top: 10px;
            text-align: center;
            font-weight: bold;
            text-shadow: 0 0 5px rgba(255,255,255,0.5);
        }
        
        /* –ö–Ω–æ–ø–∫–∏ –º–∞–≥–∞–∑–∏–Ω–∞ */
        .btn-equipped {
            border-color: #555 !important;
            color: #888 !important;
            box-shadow: none !important;
            background: rgba(50,50,50,0.5) !important;
            cursor: default;
        }
        .btn-buy {
            border-color: #FFFF00 !important;
            color: #FFFF00 !important;
            box-shadow: 0 0 15px rgba(255, 255, 0, 0.3) !important;
        }
        .btn-buy:active {
            background: #FFFF00 !important;
            color: #000 !important;
        }
        .btn-locked {
            border-color: #ff0055 !important;
            color: #ff0055 !important;
            box-shadow: none !important;
            background: rgba(20,0,0,0.5) !important;
            opacity: 0.7;
        }

        #shop-credits {
            /* –£–±—Ä–∞–Ω–æ –∞–±—Å–æ–ª—é—Ç–Ω–æ–µ –ø–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ, —Ç–µ–ø–µ—Ä—å –≤ –ø–æ—Ç–æ–∫–µ */
            position: static; 
            color: #FFFF00;
            font-size: 2.5vh;
            font-weight: bold;
            text-shadow: 0 0 10px #FFFF00;
            margin-bottom: 5px;
            text-align: center;
        }

        /* --- –ù–ê–°–¢–†–û–ô–ö–ò (–Ø–ó–´–ö) --- */
        .lang-group {
            display: flex;
            gap: 15px;
            margin-top: 15px;
            width: 100%;
            justify-content: center;
        }

        .btn-lang {
            flex: 1;
            padding: 10px;
            border: 1px solid #555;
            background: rgba(0, 0, 0, 0.5);
            color: #888;
            cursor: pointer;
            font-family: inherit;
            font-size: 2vh;
            transition: all 0.2s;
        }

        .btn-lang.active {
            border-color: #0ff;
            background: rgba(0, 255, 255, 0.2);
            color: #0ff;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.2);
        }

        /* --- HUD --- */
        #hud {
            position: absolute;
            top: 10%;
            width: 100%;
            text-align: center;
            pointer-events: none;
        }
        #score-display {
            font-size: 8vh;
            color: rgba(255, 255, 255, 0.8);
            font-weight: bold;
            text-shadow: 0 0 10px #000;
        }

        /* --- ORIENTATION WARNING --- */
        #orientation-warning {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            z-index: 10000; /* –í—ã—Å–æ—á–∞–π—à–∏–π z-index –¥–ª—è –ø–µ—Ä–µ–∫—Ä—ã—Ç–∏—è –≤—Å–µ–≥–æ */
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #0ff;
            font-size: 24px;
            text-align: center;
        }
        
        #orientation-warning svg {
            width: 64px;
            height: 64px;
            margin-bottom: 20px;
            animation: rotate-phone 2s infinite ease-in-out;
        }
        
        @keyframes rotate-phone {
            0% { transform: rotate(0deg); }
            50% { transform: rotate(-90deg); }
            100% { transform: rotate(0deg); }
        }

        /* Show warning only in landscape AND if it's a mobile device (checked in JS) */
        @media (orientation: landscape) {
            body.mobile-device #orientation-warning {
                display: flex;
            }
        }

    </style>
</head>
<body>

<!-- ORIENTATION WARNING -->
<div id="orientation-warning">
    <svg viewBox="0 0 24 24" fill="currentColor">
        <path d="M17 1.01L7 1c-1.1 0-2 .9-2 2v18c0 1.1.9 2 2 2h10c1.1 0 2-.9 2-2V3c0-1.1-.9-1.99-2-1.99zM17 19H7V5h10v14z"/>
    </svg>
    <div>–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–µ—Ä–µ–≤–µ—Ä–Ω–∏—Ç–µ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ<br>Please rotate your device</div>
</div>

<div id="game-wrapper">
    <canvas id="gameCanvas"></canvas>

    <div id="ui-layer">
        
        <!-- –í–µ—Ä—Ö–Ω—è—è –ø–∞–Ω–µ–ª—å —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è -->
        <div id="top-bar">
            <button id="btn-toggle-sound" class="icon-btn">üîä</button>
            <button id="btn-toggle-pause" class="icon-btn" style="display: none;">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg>
            </button>
        </div>

        <!-- –ö–Ω–æ–ø–∫–∞ –Ω–∞—Å—Ç—Ä–æ–µ–∫ –Ω–∞ —Å—Ç–∞—Ä—Ç–æ–≤–æ–º —ç–∫—Ä–∞–Ω–µ (–≤–∏–¥–Ω–∞ —Ç–æ–ª—å–∫–æ –≤ START) -->
        <button id="btn-settings-open" class="icon-btn">‚öôÔ∏è</button>

        <!-- HUD -->
        <div id="hud" class="hidden">
            <div id="score-display">0</div>
        </div>

        <!-- START SCREEN -->
        <div id="start-screen" class="screen">
            <h1 class="game-title" id="txt-title">CYBER<br>CAT</h1>
            <button class="btn" id="btn-start" style="min-width: 240px; min-height: 70px;">START MISSION</button>
            <button class="btn btn-shop" id="btn-shop-open">SHOP</button>
            <div style="color: #aaa; font-size: 1.5vh; margin-top: 5px;" id="txt-tap">TAP TO JUMP</div>
        </div>
        
        <!-- SHOP SCREEN -->
        <div id="shop-screen" class="screen hidden">
            <!-- –ó–∞–≥–æ–ª–æ–≤–æ–∫ —É–º–µ–Ω—å—à–µ–Ω -->
            <h1 class="game-title" id="txt-shop-title" style="font-size: 4vh; margin: 0;">ARMORY</h1>
            <!-- –ö—Ä–µ–¥–∏—Ç—ã –≤ –ø–æ—Ç–æ–∫–µ, –Ω–µ –∞–±—Å–æ–ª—é—Ç -->
            <div id="shop-credits">CREDITS: 0</div>
            
            <div class="shop-container">
                <button class="arrow-btn" id="btn-shop-prev">‚óÄ</button>
                <div class="preview-box">
                    <canvas id="shopCanvas" width="160" height="160" style="width: 160px; height: 160px;"></canvas>
                    <div class="skin-name" id="shop-skin-name">CYBER CAT</div>
                </div>
                <button class="arrow-btn" id="btn-shop-next">‚ñ∂</button>
            </div>

            <!-- –ö–æ–º–ø–∞–∫—Ç–Ω—ã–µ –∫–Ω–æ–ø–∫–∏ -->
            <button class="btn btn-shop-compact" id="btn-shop-select">SELECT</button>
            <button class="btn btn-revive btn-shop-compact" id="btn-shop-free-credits">üì∫ FREE CREDITS</button>
            <button class="btn btn-shop-compact" id="btn-shop-back">BACK</button>
        </div>

        <!-- PAUSE SCREEN -->
        <div id="pause-screen" class="screen hidden">
            <h2 class="title-paused" id="txt-paused">SYSTEM<br>PAUSED</h2>
            <button class="btn btn-resume" id="btn-resume">RESUME</button>
            <!-- –ö–Ω–æ–ø–∫–∞ –ú–µ–Ω—é –≤ –ü–∞—É–∑–µ -->
            <button class="btn btn-menu-secondary" id="btn-pause-menu" style="min-width: 240px; min-height: 70px;">MENU</button>
        </div>

        <!-- GAMEOVER SCREEN -->
        <div id="gameover-screen" class="screen hidden">
            <div class="card card-red" style="margin-bottom: 20px;">
                <div class="mission-failed" id="txt-failed">MISSION<br>FAILED</div>
                <div class="label" id="txt-score-label">SCORE</div>
                <div class="score-big" id="final-score">0</div>
                <div class="best-score-container">
                    <span class="best-label" id="txt-best-label">BEST:</span>
                    <span class="best-value" id="best-score">0</span>
                </div>
            </div>

            <!-- New Button Container -->
            <div class="gameover-buttons">
                <button class="btn btn-wide btn-revive" id="btn-revive" style="display: none;">
                    üì∫ REVIVE <span class="ad-hint">(Ad)</span>
                </button>
                <button class="btn btn-wide btn-restart" id="btn-restart">RETRY</button>
                <button class="btn btn-wide btn-menu-secondary" id="btn-gameover-menu">MENU</button>
            </div>
        </div>

        <!-- SETTINGS SCREEN -->
        <div id="settings-screen" class="screen hidden">
            <div class="card">
                <div class="label" style="color:#fff; font-size:3vh; margin-bottom:20px;" id="txt-settings-title">SETTINGS</div>
                
                <div class="label" id="txt-lang-label">LANGUAGE</div>
                <div class="lang-group">
                    <button class="btn-lang" id="btn-lang-en">ENGLISH</button>
                    <button class="btn-lang" id="btn-lang-ru">–†–£–°–°–ö–ò–ô</button>
                </div>
            </div>
            
            <button class="btn" id="btn-settings-back" style="min-width: 240px; min-height: 70px;">BACK</button>
        </div>

    </div>
</div>

<script>
/**
 * YANDEX SDK GLOBAL
 */
var ysdk = null;

// --- MOBILE CHECK FUNCTION ---
function checkMobile() {
    const userAgent = navigator.userAgent || navigator.vendor || window.opera;
    // Check user agent for common mobile strings
    const isMobileRegex = /android|avantgo|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od|ad)|iris|kindle|lge |maemo|midp|mmp|mobile|o2|opera m(ob|in)i|palm( os)?|p(ixi|re)\/|plucker|pocket|psp|smartphone|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(userAgent);
    // Check for touch capability
    const isTouch = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
    
    // If either condition is true, treat as mobile/tablet
    if (isMobileRegex || isTouch) {
        document.body.classList.add('mobile-device');
    }
}

// Call immediately
checkMobile();


/**
 * SKINS CONFIG
 */
const SKINS = [
    { id: 0, nameKey: 'skin_0', price: 0, color: '#00FFFF', flame: '#FFFF00', eyeColor: '#fff', jetpackColor: '#FFFF00', bodyColor: '#000' },
    { id: 1, nameKey: 'skin_1', price: 100, color: '#FF00FF', flame: '#ff66ff', eyeColor: '#0ff', jetpackColor: '#800080', bodyColor: '#1a001a' },
    { id: 2, nameKey: 'skin_2', price: 250, color: '#00FFFF', flame: '#e0ffff', eyeColor: '#0088ff', jetpackColor: '#C0C0C0', bodyColor: '#FFFFFF' },
    { id: 3, nameKey: 'skin_3', price: 500, color: '#FF4500', flame: '#FF4500', eyeColor: '#fff', jetpackColor: '#FF0000', bodyColor: '#110000' }, // INFERNO
    { id: 4, nameKey: 'skin_4', price: 1000, color: '#FFD700', flame: '#ffffff', eyeColor: '#fff', jetpackColor: '#DAA520', bodyColor: '#000' }
];

/**
 * LOCALIZATION SYSTEM
 */
const TRANSLATIONS = {
    'en': {
        'title': 'CYBER CAT:<br>FLIGHT',
        'mission_label': 'MISSION PROTOCOL',
        'mission_val': 'AVOID OBSTACLES',
        'tap': 'TAP TO JUMP',
        'start': 'START MISSION',
        'paused': 'SYSTEM<br>PAUSED',
        'resume': 'RESUME',
        'failed': 'MISSION<br>FAILED',
        'score_label': 'SCORE',
        'best_label': 'BEST:',
        'retry': 'RETRY',
        'revive_btn': 'üì∫ REVIVE <span class="ad-hint">(Ad)</span>',
        'settings_title': 'SETTINGS',
        'lang_label': 'LANGUAGE',
        'back': 'BACK',
        'menu_btn': 'MENU',
        'shop': 'SHOP',
        'shop_title': 'ARMORY',
        'select': 'SELECT',
        'selected': 'EQUIPPED',
        'buy': 'BUY',
        'credits': 'CREDITS',
        'free_credits': 'üì∫ AD: +100 CREDITS',
        'skin_0': 'CYBER CAT',
        'skin_1': 'NEON CAT',
        'skin_2': 'WHITE CAT',
        'skin_3': 'INFERNO CAT',
        'skin_4': 'GOLDEN CAT'
    },
    'ru': {
        'title': '–ö–ò–ë–ï–† –ö–û–¢:<br>–ü–û–õ–Å–¢',
        'mission_label': '–¶–ï–õ–¨ –ú–ò–°–°–ò–ò',
        'mission_val': '–ò–ó–ë–ï–ì–ê–ô –ü–†–ï–ü–Ø–¢–°–¢–í–ò–ô',
        'tap': '–ù–ê–ñ–ú–ò –î–õ–Ø –ü–†–´–ñ–ö–ê',
        'start': '–ù–ê–ß–ê–¢–¨',
        'paused': '–°–ò–°–¢–ï–ú–ê<br>–ù–ê –ü–ê–£–ó–ï',
        'resume': '–ü–†–û–î–û–õ–ñ–ò–¢–¨',
        'failed': '–ú–ò–°–°–ò–Ø<br>–ü–†–û–í–ê–õ–ï–ù–ê',
        'score_label': '–°–ß–ï–¢',
        'best_label': '–†–ï–ö–û–†–î:',
        'retry': '–ó–ê–ù–û–í–û',
        'revive_btn': 'üì∫ –°–ü–ê–°–¢–ò <span class="ad-hint">(–†–µ–∫–ª–∞–º–∞)</span>',
        'settings_title': '–ù–ê–°–¢–†–û–ô–ö–ò',
        'lang_label': '–Ø–ó–´–ö',
        'back': '–ù–ê–ó–ê–î',
        'menu_btn': '–ú–ï–ù–Æ',
        'shop': '–ú–ê–ì–ê–ó–ò–ù',
        'shop_title': '–ú–ê–ì–ê–ó–ò–ù',
        'select': '–í–´–ë–†–ê–¢–¨',
        'selected': '–í–´–ë–†–ê–ù–û',
        'buy': '–ö–£–ü–ò–¢–¨',
        'credits': '–ö–†–ï–î–ò–¢–´',
        'free_credits': 'üì∫ –†–ï–ö–õ–ê–ú–ê: +100',
        'skin_0': '–ö–ò–ë–ï–† –ö–û–¢',
        'skin_1': '–ù–ï–û–ù–û–í–ê–Ø –ö–û–®–ö–ê',
        'skin_2': '–ë–ï–õ–´–ô –ö–û–¢',
        'skin_3': '–ò–ù–§–ï–†–ù–û –ö–û–¢',
        'skin_4': '–ó–û–õ–û–¢–û–ô –ö–û–¢'
    }
};

class LanguageManager {
    constructor() {
        this.currentLang = 'en';
        this.init();
    }

    init() {
        if (window.ysdk && window.ysdk.environment && window.ysdk.environment.i18n) {
            this.currentLang = window.ysdk.environment.i18n.lang;
        } else {
            const userLang = navigator.language || navigator.userLanguage; 
            if (userLang) {
                this.currentLang = userLang.substr(0, 2);
            }
        }

        const isRu = ['ru', 'be', 'kk', 'uk', 'uz'].some(code => this.currentLang === code);
        this.currentLang = isRu ? 'ru' : 'en';

        this.updateTexts();
    }

    setLanguage(lang) {
        if (TRANSLATIONS[lang]) {
            this.currentLang = lang;
            this.updateTexts();
            this.updateButtons();
        }
    }

    updateButtons() {
        const btnEn = document.getElementById('btn-lang-en');
        const btnRu = document.getElementById('btn-lang-ru');
        
        if (this.currentLang === 'en') {
            btnEn.classList.add('active');
            btnRu.classList.remove('active');
        } else {
            btnEn.classList.remove('active');
            btnRu.classList.add('active');
        }
    }

    updateTexts() {
        const t = TRANSLATIONS[this.currentLang];
        
        const setText = (id, text) => {
            const el = document.getElementById(id);
            if (el) el.innerHTML = text;
        };

        setText('txt-title', t.title);
        setText('txt-mission-label', t.mission_label);
        setText('txt-mission-val', t.mission_val);
        setText('txt-tap', t.tap);
        setText('btn-start', t.start);
        setText('btn-shop-open', t.shop);
        setText('txt-shop-title', t.shop_title);
        setText('txt-paused', t.paused);
        setText('btn-resume', t.resume);
        setText('txt-failed', t.failed);
        setText('txt-score-label', t.score_label);
        setText('txt-best-label', t.best_label);
        setText('btn-restart', t.retry);
        setText('btn-revive', t.revive_btn);
        setText('txt-settings-title', t.settings_title);
        setText('txt-lang-label', t.lang_label);
        setText('btn-settings-back', t.back);
        setText('btn-shop-back', t.back);
        setText('btn-shop-free-credits', t.free_credits);
        setText('btn-pause-menu', t.menu_btn);
        setText('btn-gameover-menu', t.menu_btn);
    }
    
    get(key) {
        return TRANSLATIONS[this.currentLang][key] || key;
    }
}

/**
 * AUDIO SYSTEM
 */
class SoundManager {
    constructor() {
        this.ctx = null;
        this.masterGain = null; // –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è: –û–±—â–∏–π —É–∑–µ–ª —É—Å–∏–ª–µ–Ω–∏—è
        this.muted = false;
        this.initialized = false;
        this.lastJumpTime = 0; // –õ–∏–º–∏—Ç–µ—Ä –¥–ª—è –ø—Ä—ã–∂–∫–∞
    }

    init() {
        if (this.initialized) return;
        try {
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            this.ctx = new AudioContext({ latencyHint: 'interactive' });
            
            // –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è: –°–æ–∑–¥–∞–µ–º Master Gain –æ–¥–∏–Ω —Ä–∞–∑
            this.masterGain = this.ctx.createGain();
            this.masterGain.gain.value = 0.5; // –û–±—â–∞—è –≥—Ä–æ–º–∫–æ—Å—Ç—å
            this.masterGain.connect(this.ctx.destination);
            
            this.initialized = true;
        } catch (e) {
            console.error('Web Audio API not supported');
        }
    }

    toggleMute() {
        this.muted = !this.muted;
        // Resume if unmuted
        if (!this.muted && this.ctx && this.ctx.state === 'suspended') {
            this.ctx.resume();
        }
        return this.muted;
    }

    suspendAudio() {
        if (this.ctx && this.ctx.state === 'running') {
            this.ctx.suspend();
        }
    }

    resumeAudio() {
        if (this.ctx && this.ctx.state === 'suspended' && !this.muted) {
            this.ctx.resume();
        }
    }

    // Helper to ensure context is ready
    _ready() {
        if (!this.initialized) this.init();
        if (!this.ctx) return false;
        if (this.muted) return false;
        if (this.ctx.state === 'suspended') this.ctx.resume();
        return true;
    }

    // –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è: –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–π –º–µ—Ç–æ–¥ –¥–ª—è –æ—á–∏—Å—Ç–∫–∏
    _cleanup(osc, gain) {
        osc.onended = () => {
            osc.disconnect();
            gain.disconnect();
        };
    }

    playJump() {
        if (!this._ready()) return;

        // –õ–∏–º–∏—Ç–µ—Ä: –Ω–µ –∏–≥—Ä–∞—Ç—å —á–∞—â–µ —á–µ–º —Ä–∞–∑ –≤ 80–º—Å
        const now = Date.now();
        if (now - this.lastJumpTime < 80) return;
        this.lastJumpTime = now;

        const t = this.ctx.currentTime;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();

        // –ü–æ–¥–∫–ª—é—á–∞–µ–º –∫ MasterGain –≤–º–µ—Å—Ç–æ destination
        osc.connect(gain);
        gain.connect(this.masterGain);

        osc.type = 'square';
        osc.frequency.setValueAtTime(150, t);
        osc.frequency.exponentialRampToValueAtTime(400, t + 0.05);

        gain.gain.setValueAtTime(0.1, t);
        gain.gain.exponentialRampToValueAtTime(0.001, t + 0.05);

        osc.start(t);
        osc.stop(t + 0.05);
        
        // –í–∞–∂–Ω–æ: –û—á–∏—Å—Ç–∫–∞ —Ä–µ—Å—É—Ä—Å–æ–≤
        this._cleanup(osc, gain);
    }

    playScore() {
        if (!this._ready()) return;
        
        const t = this.ctx.currentTime;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();

        osc.connect(gain);
        gain.connect(this.masterGain);

        osc.type = 'sine';
        osc.frequency.setValueAtTime(800, t);
        osc.frequency.exponentialRampToValueAtTime(1500, t + 0.08);

        gain.gain.setValueAtTime(0.05, t);
        gain.gain.linearRampToValueAtTime(0.0, t + 0.08);

        osc.start(t);
        osc.stop(t + 0.08);
        
        this._cleanup(osc, gain);
    }

    playCrash() {
        if (!this._ready()) return;
        
        const t = this.ctx.currentTime;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();

        osc.connect(gain);
        gain.connect(this.masterGain);

        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(100, t);
        osc.frequency.exponentialRampToValueAtTime(10, t + 0.3);

        gain.gain.setValueAtTime(0.1, t);
        gain.gain.exponentialRampToValueAtTime(0.001, t + 0.3);

        osc.start(t);
        osc.stop(t + 0.3);
        
        this._cleanup(osc, gain);
    }
    
    // --- NEW SOUNDS ---
    playTone(freq, type, duration, vol = 0.1) {
        if (!this._ready()) return;
        const t = this.ctx.currentTime;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        
        osc.connect(gain);
        gain.connect(this.masterGain);
        
        osc.type = type;
        osc.frequency.setValueAtTime(freq, t);
        
        gain.gain.setValueAtTime(vol, t);
        gain.gain.exponentialRampToValueAtTime(0.001, t + duration);
        
        osc.start(t);
        osc.stop(t + duration);
        
        this._cleanup(osc, gain);
    }

    playUiClick() {
        // High blip
        this.playTone(1200, 'sine', 0.1, 0.05);
    }

    playUiBack() {
        // Low blip
        this.playTone(400, 'sine', 0.15, 0.05);
    }

    playShopSuccess() {
        if (!this._ready()) return;
        
        const t = this.ctx.currentTime;
        // C5, E5 (—Å–æ–∫—Ä–∞—Ç–∏–ª–∏ –¥–æ 2 –Ω–æ—Ç –¥–ª—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏)
        [523.25, 659.25].forEach((freq, i) => {
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            
            osc.connect(gain);
            gain.connect(this.masterGain);
            
            osc.type = 'square';
            osc.frequency.setValueAtTime(freq, t + i * 0.08);
            
            gain.gain.setValueAtTime(0.05, t + i * 0.08);
            gain.gain.exponentialRampToValueAtTime(0.001, t + i * 0.08 + 0.1);
            
            osc.start(t + i * 0.08);
            osc.stop(t + i * 0.08 + 0.1);
            
            this._cleanup(osc, gain);
        });
    }

    playShopError() {
        if (!this._ready()) return;
        
        const t = this.ctx.currentTime;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        
        osc.connect(gain);
        gain.connect(this.masterGain);
        
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(150, t);
        osc.frequency.linearRampToValueAtTime(100, t + 0.2);
        
        gain.gain.setValueAtTime(0.1, t);
        gain.gain.linearRampToValueAtTime(0.0, t + 0.2);
        
        osc.start(t);
        osc.stop(t + 0.2);
        
        this._cleanup(osc, gain);
    }

    playEquip() {
        if (!this._ready()) return;
        
        const t = this.ctx.currentTime;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        
        osc.connect(gain);
        gain.connect(this.masterGain);
        
        osc.type = 'triangle';
        osc.frequency.setValueAtTime(800, t);
        osc.frequency.exponentialRampToValueAtTime(100, t + 0.1);
        
        gain.gain.setValueAtTime(0.1, t);
        gain.gain.exponentialRampToValueAtTime(0.001, t + 0.1);
        
        osc.start(t);
        osc.stop(t + 0.1);
        
        this._cleanup(osc, gain);
    }
    
    playBuy() {
        this.playShopSuccess();
    }
}

/**
 * –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–Ø
 */
const CONFIG = {
    // Remove logicalHeight as it is dynamic
    logicalWidth: 720,
    
    // Physics (px/sec)
    gravity: 1900,        
    jumpForce: -620,       
    terminalVelocity: 1000,
    
    // Difficulty
    initialSpeed: 350,
    speed: 350,          // Current Speed
    speedIncreaseStep: 1.5,
    maxSpeed: 600,
    
    // Balancing
    gapSize: 220, 
    minPipeDistance: 480
};

const STATE = {
    START: 0,
    PLAYING: 1,
    PAUSED: 2,
    GAMEOVER: 3,
    SETTINGS: 4,
    SHOP: 5
};

/**
 * –ö–õ–ê–°–° –ò–ì–†–´
 */
class Game {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.wrapper = document.getElementById('game-wrapper');

        // Initial setup - will be updated in resize
        this.canvas.width = CONFIG.logicalWidth;
        this.canvas.height = 1280; // Placeholder

        this.ui = {
            start: document.getElementById('start-screen'),
            gameover: document.getElementById('gameover-screen'),
            pause: document.getElementById('pause-screen'),
            settings: document.getElementById('settings-screen'),
            shop: document.getElementById('shop-screen'),
            hud: document.getElementById('hud'),
            score: document.getElementById('score-display'),
            finalScore: document.getElementById('final-score'),
            bestScore: document.getElementById('best-score'),
            btnStart: document.getElementById('btn-start'),
            btnShopOpen: document.getElementById('btn-shop-open'),
            btnShopBack: document.getElementById('btn-shop-back'),
            btnShopPrev: document.getElementById('btn-shop-prev'),
            btnShopNext: document.getElementById('btn-shop-next'),
            btnShopSelect: document.getElementById('btn-shop-select'),
            btnShopFreeCredits: document.getElementById('btn-shop-free-credits'),
            shopSkinName: document.getElementById('shop-skin-name'),
            shopCanvas: document.getElementById('shopCanvas'),
            shopCredits: document.getElementById('shop-credits'),
            btnRestart: document.getElementById('btn-restart'),
            btnRevive: document.getElementById('btn-revive'),
            btnResume: document.getElementById('btn-resume'),
            btnPauseMenu: document.getElementById('btn-pause-menu'),
            btnGameOverMenu: document.getElementById('btn-gameover-menu'),
            btnPause: document.getElementById('btn-toggle-pause'),
            btnSound: document.getElementById('btn-toggle-sound'),
            btnSettingsOpen: document.getElementById('btn-settings-open'),
            btnSettingsBack: document.getElementById('btn-settings-back'),
            btnLangEn: document.getElementById('btn-lang-en'),
            btnLangRu: document.getElementById('btn-lang-ru')
        };

        this.langManager = new LanguageManager();
        this.langManager.updateButtons();

        this.sound = new SoundManager();
        this.state = STATE.START;
        
        this.lastTime = 0;
        this.score = 0;
        this.highScore = localStorage.getItem('cybercat_highscore') || 0;
        this.credits = parseInt(localStorage.getItem('cybercat_credits')) || 0;
        this.inventory = JSON.parse(localStorage.getItem('cybercat_inventory')) || [0];
        
        this.hasRevived = false;

        // COOLDOWN LOGIC
        this.lastGameOverTime = 0;

        // SHOP STATE
        this.selectedSkinId = parseInt(localStorage.getItem('cybercat_skin')) || 0;
        this.browsingSkinIndex = this.selectedSkinId;
        this.shopCtx = this.ui.shopCanvas.getContext('2d');

        this.cat = new Cat(this);
        this.obstacles = [];
        this.background = new Background(this);

        this.particlePool = [];
        for(let i=0; i<50; i++) {
            this.particlePool.push(new Particle());
            this.particlePool[i].active = false;
        }

        this.initListeners();
        this.resize();
        
        requestAnimationFrame((t) => this.loop(t));
    }

    initListeners() {
        window.addEventListener('resize', () => this.resize());
        
        // --- AUDIO UNLOCKER ---
        const unlockAudio = () => {
            this.sound.init();
            this.sound.resumeAudio();
            document.removeEventListener('pointerdown', unlockAudio);
            document.removeEventListener('keydown', unlockAudio);
        };
        document.addEventListener('pointerdown', unlockAudio);
        document.addEventListener('keydown', unlockAudio);

        // --- AUDIO SUSPEND ON TAB HIDE (Rule Fix) ---
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                // –ò–≥—Ä–æ–∫ —É—à–µ–ª —Å–æ –≤–∫–ª–∞–¥–∫–∏: –ì–ª—É—à–∏–º –∑–≤—É–∫ –∏ —Å—Ç–∞–≤–∏–º –ø–∞—É–∑—É
                this.sound.suspendAudio();
                if (this.state === STATE.PLAYING) {
                    this.togglePause();
                }
            } else {
                // –ò–≥—Ä–æ–∫ –≤–µ—Ä–Ω—É–ª—Å—è: –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∑–≤—É–∫
                this.sound.resumeAudio();
            }
        });

        const startAction = (e) => {
            e.preventDefault();
            this.sound.init();
            this.sound.playUiClick();
            this.startGame();
        };
        this.ui.btnStart.addEventListener('click', startAction);
        
        this.ui.btnRestart.addEventListener('click', (e) => {
            e.preventDefault();
            this.sound.playUiClick();
            this.showAdAndRestart();
        });

        this.ui.btnRevive.addEventListener('click', (e) => {
            e.preventDefault();
            this.sound.playUiClick();
            this.showReviveAd();
        });

        this.ui.btnResume.addEventListener('click', (e) => {
            e.preventDefault();
            this.sound.playUiClick();
            this.togglePause();
        });

        // SHOP LISTENERS
        this.ui.btnShopOpen.addEventListener('click', (e) => {
            e.preventDefault();
            this.sound.playUiClick();
            this.openShop();
        });
        this.ui.btnShopBack.addEventListener('click', (e) => {
            e.preventDefault();
            this.sound.playUiBack();
            this.closeShop();
        });
        this.ui.btnShopPrev.addEventListener('click', (e) => {
            e.preventDefault();
            this.sound.playUiClick();
            this.changeBrowseSkin(-1);
        });
        this.ui.btnShopNext.addEventListener('click', (e) => {
            e.preventDefault();
            this.sound.playUiClick();
            this.changeBrowseSkin(1);
        });
        this.ui.btnShopSelect.addEventListener('click', (e) => {
            e.preventDefault();
            this.handleShopAction();
        });
        this.ui.btnShopFreeCredits.addEventListener('click', (e) => {
             e.preventDefault();
             this.sound.playUiClick();
             this.watchAdForCredits();
        });

        const menuHandler = (e) => {
            e.preventDefault();
            this.sound.playUiBack();
            
            // Show Ad before exit
            if (window.ysdk) {
                this.sound.suspendAudio();
                window.ysdk.adv.showFullscreenAdv({
                    callbacks: {
                        onClose: (wasShown) => {
                            this.sound.resumeAudio();
                            this.exitToMenu();
                        },
                        onError: (error) => {
                            this.sound.resumeAudio();
                            this.exitToMenu();
                        }
                    }
                });
            } else {
                this.exitToMenu();
            }
        };
        this.ui.btnPauseMenu.addEventListener('click', menuHandler);
        this.ui.btnGameOverMenu.addEventListener('click', menuHandler);

        this.ui.btnPause.addEventListener('click', (e) => {
            e.stopPropagation();
            this.sound.playUiClick();
            this.togglePause();
        });

        this.ui.btnSound.addEventListener('click', (e) => {
            e.stopPropagation();
            const isMuted = this.sound.toggleMute();
            this.sound.playUiClick();
            this.ui.btnSound.innerText = isMuted ? 'üîá' : 'üîä';
            this.ui.btnSound.classList.toggle('muted', isMuted);
        });

        this.ui.btnSettingsOpen.addEventListener('click', (e) => {
            e.stopPropagation();
            this.sound.playUiClick();
            this.openSettings();
        });

        this.ui.btnSettingsBack.addEventListener('click', (e) => {
            e.stopPropagation();
            this.sound.playUiBack();
            this.closeSettings();
        });

        this.ui.btnLangEn.addEventListener('click', (e) => {
            e.stopPropagation();
            this.sound.playUiClick();
            this.langManager.setLanguage('en');
            this.updateShopUI(); // Update texts if shop is open
        });

        this.ui.btnLangRu.addEventListener('click', (e) => {
            e.stopPropagation();
            this.sound.playUiClick();
            this.langManager.setLanguage('ru');
            this.updateShopUI();
        });


        this.wrapper.addEventListener('pointerdown', (e) => {
            if (e.target.tagName === 'BUTTON') return;
            if (this.state === STATE.PLAYING) {
                this.cat.jump();
            }
        });

        // =========================================================
        // FIXED KEYDOWN LOGIC (STRICT STATE HANDLING)
        // =========================================================
        window.addEventListener('keydown', (e) => {
            const code = e.code;
            const isActionKey = (code === 'Space' || code === 'ArrowUp');

            // 1. –í—Å–µ–≥–¥–∞ –±–ª–æ–∫–∏—Ä—É–µ–º —Å–∫—Ä–æ–ª–ª –¥–ª—è –∏–≥—Ä–æ–≤—ã—Ö –∫–ª–∞–≤–∏—à
            if (isActionKey) {
                e.preventDefault();
            }

            // 2. Strict Switch Logic
            switch (this.state) {
                case STATE.START:
                    // –ï—Å–ª–∏ –Ω–∞–∂–∞–ª–∏ –ü—Ä–æ–±–µ–ª –≤ –º–µ–Ω—é - —Å—Ç–∞—Ä—Ç –∏–≥—Ä—ã
                    if (isActionKey) {
                        this.sound.init(); // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∑–≤—É–∫–∞ –µ—Å–ª–∏ –µ—â–µ –Ω–µ –±—ã–ª–æ
                        this.startGame();
                    }
                    break;

                case STATE.PLAYING:
                    // –í –∏–≥—Ä–µ - —Ç–æ–ª—å–∫–æ –ø—Ä—ã–∂–æ–∫
                    if (isActionKey) {
                        this.cat.jump();
                    }
                    // –ü–∞—É–∑–∞ –ø–æ Escape
                    if (code === 'Escape') {
                        this.togglePause();
                    }
                    break;

                case STATE.GAMEOVER:
                    // –†–µ—Å—Ç–∞—Ä—Ç —Ç–æ–ª—å–∫–æ —Å –∑–∞–¥–µ—Ä–∂–∫–æ–π (—á—Ç–æ–±—ã –Ω–µ –ø—Ä–æ–ø—É—Å—Ç–∏—Ç—å —ç–∫—Ä–∞–Ω —Å–º–µ—Ä—Ç–∏ —Å–ª—É—á–∞–π–Ω—ã–º –∫–ª–∏–∫–æ–º)
                    if (isActionKey) {
                        const now = Date.now();
                        // 1000ms cooldown
                        if (now - this.lastGameOverTime > 1000) {
                            this.showAdAndRestart();
                        }
                    }
                    break;

                case STATE.PAUSED:
                    // –í –ø–∞—É–∑–µ –ø—Ä–æ–±–µ–ª –Ω–µ –¥–æ–ª–∂–µ–Ω —Å–Ω–∏–º–∞—Ç—å —Å –ø–∞—É–∑—ã (—Ç–æ–ª—å–∫–æ –∫–Ω–æ–ø–∫–∞ –∏–ª–∏ Escape)
                    if (code === 'Escape') {
                        this.togglePause();
                    }
                    break;

                case STATE.SHOP:
                case STATE.SETTINGS:
                    // –í –º–∞–≥–∞–∑–∏–Ω–∞—Ö –∏ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö –ø—Ä–æ–±–µ–ª –∏–≥–Ω–æ—Ä–∏—Ä—É–µ–º
                    break;
            }
        });
    }

    spawnParticle(x, y) {
        const p = this.particlePool.find(p => !p.active);
        if (p) p.activate(x, y, this.selectedSkinId);
    }

    resize() {
        const winW = window.innerWidth;
        const winH = window.innerHeight;
        // Use a safe aspect ratio, constrained by CSS max-width which is 60vh ~ 0.6 aspect
        // But for internal calculation, we want to map full height.
        // effectiveWidth is how wide the game LOOKS. 
        const effectiveWidth = Math.min(winW, winH * 0.6); 
        const aspect = effectiveWidth / winH;
        
        this.canvas.width = CONFIG.logicalWidth;
        this.canvas.height = CONFIG.logicalWidth / aspect;
    }

    /* --- SHOP LOGIC --- */
    openShop() {
        this.state = STATE.SHOP;
        this.browsingSkinIndex = this.selectedSkinId;
        this.ui.start.classList.add('hidden');
        this.ui.shop.classList.remove('hidden');
        this.ui.btnSettingsOpen.style.display = 'none';
        this.updateShopUI();
    }

    closeShop() {
        this.state = STATE.START;
        this.ui.shop.classList.add('hidden');
        this.ui.start.classList.remove('hidden');
        this.ui.btnSettingsOpen.style.display = 'block';
    }

    changeBrowseSkin(delta) {
        let newIndex = this.browsingSkinIndex + delta;
        if (newIndex < 0) newIndex = SKINS.length - 1;
        if (newIndex >= SKINS.length) newIndex = 0;
        this.browsingSkinIndex = newIndex;
        this.updateShopUI();
    }

    handleShopAction() {
        const skin = SKINS[this.browsingSkinIndex];
        const isOwned = this.inventory.includes(skin.id);

        if (isOwned) {
            // Select logic
            this.selectedSkinId = this.browsingSkinIndex;
            localStorage.setItem('cybercat_skin', this.selectedSkinId);
            this.cat.updateSkin();
            this.sound.playEquip(); // Play equip sound
            this.updateShopUI();
        } else {
            // Buy logic
            if (this.credits >= skin.price) {
                this.credits -= skin.price;
                this.inventory.push(skin.id);
                this.selectedSkinId = skin.id; // Auto select on buy
                
                // Save data
                localStorage.setItem('cybercat_credits', this.credits);
                localStorage.setItem('cybercat_inventory', JSON.stringify(this.inventory));
                localStorage.setItem('cybercat_skin', this.selectedSkinId);
                
                this.sound.playShopSuccess(); // Play success sound
                this.cat.updateSkin();
                this.updateShopUI();
            } else {
                // Not enough money
                this.sound.playShopError(); // Play error sound
                this.ui.btnShopSelect.classList.add('btn-locked');
                setTimeout(() => {
                    this.updateShopUI(); // reset style
                }, 300);
            }
        }
    }
    
    watchAdForCredits() {
        let rewardGranted = false;
        const finishAd = () => {
            this.sound.resumeAudio();
            if (rewardGranted) {
                 this.credits += 100;
                 localStorage.setItem('cybercat_credits', this.credits);
                 this.sound.playShopSuccess();
                 this.updateShopUI();
            }
        };

        if (window.ysdk) {
            this.sound.suspendAudio();
            window.ysdk.adv.showRewardedVideo({
                callbacks: {
                    onOpen: () => {},
                    onRewarded: () => { rewardGranted = true; },
                    onClose: () => { finishAd(); },
                    onError: (e) => { finishAd(); }
                }
            });
        } else {
            // Mock for testing
            rewardGranted = true;
            finishAd();
        }
    }

    updateShopUI() {
        const skin = SKINS[this.browsingSkinIndex];
        this.ui.shopSkinName.innerText = this.langManager.get(skin.nameKey);
        this.ui.shopCredits.innerText = `${this.langManager.get('credits')}: ${this.credits}`;
        this.ui.btnShopFreeCredits.innerHTML = this.langManager.get('free_credits');
        
        // Update Title via Language Manager to ensure correct language
        const shopTitle = document.getElementById('txt-shop-title');
        if (shopTitle) shopTitle.innerText = this.langManager.get('shop_title');

        const isOwned = this.inventory.includes(skin.id);
        const isSelected = this.selectedSkinId === skin.id;

        // Reset Styles
        this.ui.btnShopSelect.classList.remove('btn-equipped', 'btn-buy', 'btn-locked');
        this.ui.btnShopSelect.style.borderColor = "";

        if (isOwned) {
            if (isSelected) {
                this.ui.btnShopSelect.innerText = this.langManager.get('selected');
                this.ui.btnShopSelect.classList.add('btn-equipped');
            } else {
                this.ui.btnShopSelect.innerText = this.langManager.get('select');
            }
        } else {
            this.ui.btnShopSelect.innerText = `${this.langManager.get('buy')} (${skin.price})`;
            if (this.credits >= skin.price) {
                this.ui.btnShopSelect.classList.add('btn-buy');
            } else {
                this.ui.btnShopSelect.classList.add('btn-locked');
            }
        }
    }

    drawShopPreview() {
        const ctx = this.shopCtx;
        ctx.clearRect(0, 0, 160, 160);
        
        // Background glow
        const skin = SKINS[this.browsingSkinIndex];
        ctx.save();
        ctx.fillStyle = "#111";
        ctx.fillRect(0,0,160,160);
        
        // Draw Cat in Center
        ctx.translate(80, 80);
        
        // Use Global Draw Function
        drawCatVisuals(ctx, 50, 40, this.browsingSkinIndex, null); 

        ctx.restore();
    }

    openSettings() {
        if (this.state === STATE.START) {
            this.previousState = STATE.START;
        } else if (this.state === STATE.PAUSED) {
            this.previousState = STATE.PAUSED;
        } else {
            this.previousState = STATE.START; 
        }

        this.state = STATE.SETTINGS;
        
        this.ui.start.classList.add('hidden');
        this.ui.pause.classList.add('hidden');
        this.ui.gameover.classList.add('hidden');
        
        this.ui.settings.classList.remove('hidden');
        this.ui.btnSettingsOpen.style.display = 'none';
        this.ui.btnPause.style.display = 'none';
    }

    closeSettings() {
        if (this.state === STATE.SETTINGS) {
            this.state = this.previousState;
            this.ui.settings.classList.add('hidden');
            
            if (this.state === STATE.START) {
                this.ui.start.classList.remove('hidden');
                this.ui.btnSettingsOpen.style.display = 'block';
            } else if (this.state === STATE.PAUSED) {
                this.ui.pause.classList.remove('hidden');
            }
        }
    }

    exitToMenu() {
        this.state = STATE.START;
        
        this.ui.settings.classList.add('hidden');
        this.ui.pause.classList.add('hidden');
        this.ui.gameover.classList.add('hidden');
        this.ui.hud.classList.add('hidden');
        
        this.ui.start.classList.remove('hidden');
        this.ui.btnSettingsOpen.style.display = 'block';
        this.ui.btnPause.style.display = 'none';

        this.cat.reset();
        this.obstacles = [];
        this.particlePool.forEach(p => p.active = false);
        this.score = 0;
        CONFIG.speed = CONFIG.initialSpeed;
        this.hasRevived = false;
        
        this.lastTime = performance.now();
    }

    startGame() {
        this.state = STATE.PLAYING;
        this.ui.start.classList.add('hidden');
        this.ui.settings.classList.add('hidden');
        this.ui.hud.classList.remove('hidden');
        this.ui.btnPause.style.display = 'flex';
        this.ui.btnSettingsOpen.style.display = 'none';
        
        CONFIG.speed = CONFIG.initialSpeed;
        this.hasRevived = false;
        
        this.cat.updateSkin(); // Ensure correct skin on start
        this.cat.reset(); 
        this.cat.jump();
        this.score = 0;
        this.updateScoreUI();
        this.lastTime = performance.now();
    }

    showAdAndRestart() {
        const finishAd = () => {
            this.sound.resumeAudio();
            this.resetGame();
        };

        if (window.ysdk) {
            this.sound.suspendAudio();
            window.ysdk.adv.showFullscreenAdv({
                callbacks: {
                    onClose: function(wasShown) { finishAd(); },
                    onError: function(error) { finishAd(); }
                }
            });
        } else {
            finishAd();
        }
    }

    showReviveAd() {
        let rewardGranted = false;
        const finishRevive = () => {
            this.sound.resumeAudio();
            if (rewardGranted) {
                this.reviveHero();
            }
        };

        if (window.ysdk) {
            this.sound.suspendAudio();
            window.ysdk.adv.showRewardedVideo({
                callbacks: {
                    onOpen: () => { console.log('Video ad open.'); },
                    onRewarded: () => { rewardGranted = true; },
                    onClose: () => { finishRevive(); },
                    onError: (e) => { finishRevive(); }
                }
            });
        } else {
            rewardGranted = true; 
            finishRevive();
        }
    }

    reviveHero() {
        this.hasRevived = true;
        this.state = STATE.PLAYING;
        
        this.ui.gameover.classList.add('hidden');
        this.ui.hud.classList.remove('hidden');
        this.ui.btnPause.style.display = 'flex';

        this.cat.y = this.canvas.height / 2;
        this.cat.velocity = 0;
        this.cat.rotation = 0;
        this.obstacles = [];

        this.lastTime = performance.now();
        this.cat.jump();
    }

    resetGame() {
        this.cat = new Cat(this);
        this.obstacles = [];
        this.particlePool.forEach(p => p.active = false);
        this.score = 0;
        this.hasRevived = false;
        
        CONFIG.speed = CONFIG.initialSpeed;
        
        this.state = STATE.PLAYING;
        this.ui.gameover.classList.add('hidden');
        this.ui.hud.classList.remove('hidden');
        this.ui.btnPause.style.display = 'flex';
        this.cat.jump();
        this.updateScoreUI();
        this.lastTime = performance.now();
    }

    togglePause() {
        if (this.state === STATE.PLAYING) {
            this.state = STATE.PAUSED;
            this.ui.pause.classList.remove('hidden');
            this.ui.btnPause.style.display = 'none';
        } else if (this.state === STATE.PAUSED) {
            this.state = STATE.PLAYING;
            this.ui.pause.classList.add('hidden');
            this.ui.btnPause.style.display = 'flex';
            this.lastTime = performance.now();
        }
    }

    gameOver() {
        this.ui.gameover.classList.remove('hidden');
        this.state = STATE.GAMEOVER;
        
        // SET COOLDOWN TIMER
        this.lastGameOverTime = Date.now();
        
        try {
            this.sound.playCrash();
        } catch (e) {
            console.error('Audio play failed', e);
        }
        
        // Economy Logic
        this.credits += this.score;
        localStorage.setItem('cybercat_credits', this.credits);
        
        if (this.score > this.highScore) {
            this.highScore = this.score;
            localStorage.setItem('cybercat_highscore', this.highScore);
        }

        this.ui.hud.classList.add('hidden');
        this.ui.btnPause.style.display = 'none';
        this.ui.finalScore.innerText = this.score;
        this.ui.bestScore.innerText = this.highScore;

        if (!this.hasRevived) {
            this.ui.btnRevive.style.display = 'flex';
        } else {
            this.ui.btnRevive.style.display = 'none';
        }
    }

    updateScoreUI() {
        this.ui.score.innerText = this.score;
    }

    loop(timestamp) {
        if (!this.lastTime) this.lastTime = timestamp;
        const dt = (timestamp - this.lastTime) / 1000;
        this.lastTime = timestamp;

        this.update(dt);
        this.draw();
        
        requestAnimationFrame((t) => this.loop(t));
    }

    update(dt) {
        // Animation for shop
        if (this.state === STATE.SHOP) {
            this.drawShopPreview();
            return;
        }

        if (this.state === STATE.PAUSED || this.state === STATE.SETTINGS) return;
        if (dt > 0.1) dt = 0.1;

        this.background.update(dt);
        this.particlePool.forEach(p => p.update(dt));

        if (this.state === STATE.PLAYING) {
            this.cat.update(dt);
            
            const speedRatio = (CONFIG.speed - CONFIG.initialSpeed) / (CONFIG.maxSpeed - CONFIG.initialSpeed);
            const dynamicMinDistance = CONFIG.minPipeDistance - (speedRatio * 50);

            if (this.obstacles.length === 0) {
                this.obstacles.push(new Obstacle(this));
            } else {
                const lastObs = this.obstacles[this.obstacles.length - 1];
                if (CONFIG.logicalWidth - lastObs.x >= dynamicMinDistance) {
                    this.obstacles.push(new Obstacle(this, lastObs));
                }
            }

            const hitPaddingX = this.cat.w * 0.2;
            const hitPaddingY = this.cat.h * 0.2;
            
            const catHitL = this.cat.x + hitPaddingX;
            const catHitR = this.cat.x + this.cat.w - hitPaddingX;
            const catHitT = this.cat.y + hitPaddingY;
            const catHitB = this.cat.y + this.cat.h - hitPaddingY;

            for (let i = this.obstacles.length - 1; i >= 0; i--) {
                const obs = this.obstacles[i];
                obs.update(dt);
                
                if (!obs.passed && this.cat.x > obs.x + obs.w) {
                    obs.passed = true;
                    this.score++;
                    this.updateScoreUI();
                    this.sound.playScore();
                    
                    CONFIG.speed = Math.min(CONFIG.maxSpeed, CONFIG.speed + CONFIG.speedIncreaseStep);
                }

                if (obs.x + obs.w < 0) {
                    this.obstacles.splice(i, 1);
                    continue;
                }

                if (
                    catHitR > obs.x &&
                    catHitL < obs.x + obs.w &&
                    (catHitT < obs.topHeight || catHitB > obs.bottomY)
                ) {
                    this.gameOver();
                }
            }

            if (this.cat.y + this.cat.h >= this.canvas.height || this.cat.y <= 0) {
                this.gameOver();
            }

        } else if (this.state === STATE.GAMEOVER) {
            if (this.cat.y + this.cat.h < this.canvas.height) {
                this.cat.velocity += CONFIG.gravity * dt;
                this.cat.y += this.cat.velocity * dt;
            }
        }
    }

    draw() {
        // Skip main draw if in shop
        if (this.state === STATE.SHOP) return;

        this.ctx.fillStyle = "#0d001a";
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        this.background.draw(this.ctx);
        this.obstacles.forEach(obs => obs.draw(this.ctx));
        this.particlePool.forEach(p => p.draw(this.ctx));
        this.cat.draw(this.ctx);

        if (this.state === STATE.PAUSED || this.state === STATE.SETTINGS) {
            this.ctx.fillStyle = "rgba(0,0,0,0.3)";
            this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        }
    }
}

/**
 * VISUAL HELPER FUNCTION (Global)
 */
function drawCatVisuals(ctx, w, h, skinId, velocity) {
    const skin = SKINS[skinId];
    
    // --- SETUP STYLES ---
    let fillColor = "#000";
    let strokeColor = skin.color;
    
    if (skinId === 2) { // PHANTOM
        fillColor = "#ffffff";
        strokeColor = "#00FFFF"; // Explicit Cyan stroke
    } else if (skinId === 4) { // MIDAS
        let grd = ctx.createLinearGradient(-w/2, -h/2, w/2, h/2);
        grd.addColorStop(0, "#FFD700"); 
        grd.addColorStop(1, "#FFA500"); 
        fillColor = grd;
        strokeColor = "#FFA500";
    } else if (skinId === 3) { // INFERNO
        fillColor = "#110000";
    } else if (skinId === 1) { // PLASMA
        fillColor = "#1a001a";
    }
    
    // Override if specific body color exists in config (mostly for fallback)
    if (skin.bodyColor && skinId !== 4) fillColor = skin.bodyColor;

    // --- LAYER 1: JETPACK & FLAME ---
    // Flame (behind jetpack)
    if (velocity < 0 || velocity === null) {
        const flameLength = 20 + Math.random() * 15;
        let flameColor = skin.flame;
        
        if (velocity !== null && CONFIG.speed > 500) {
             flameColor = Math.random() > 0.5 ? "#FFFFFF" : flameColor; 
        }
        
        ctx.fillStyle = flameColor;
        ctx.shadowBlur = 20;
        ctx.shadowColor = flameColor;
        
        ctx.beginPath();
        ctx.moveTo(-w/2 - 10, -5); 
        ctx.lineTo(-w/2 - 10 - flameLength, 5);
        ctx.lineTo(-w/2 - 10, 15);
        ctx.fill();
        ctx.shadowBlur = 0; 
    }

    // Jetpack Body
    ctx.fillStyle = skin.jetpackColor || '#555';
    ctx.fillRect(-w/2 - 10, -5, 10, 20);

    // --- LAYER 3: BODY ---
    ctx.shadowBlur = (skinId === 4 || skinId === 2) ? 25 : 15; 
    ctx.shadowColor = skin.color;
    if (skinId === 4) ctx.shadowColor = "#FFD700";
    
    ctx.strokeStyle = strokeColor;
    ctx.lineWidth = 3;
    ctx.fillStyle = fillColor;

    ctx.fillRect(-w/2, -h/2, w, h);
    ctx.strokeRect(-w/2, -h/2, w, h);

    // --- LAYER 4: EARS (Logic) ---
    // If Midas (4) -> Skip ears (draw crown later)
    if (skinId !== 4) {
        ctx.lineWidth = 2;
        ctx.strokeStyle = strokeColor; 
        
        // Standard ear height is -15, Neon Cat (1) gets slightly taller ears (-16 instead of -17)
        let yTop = (skinId === 1) ? -16 : -15;

        ctx.beginPath();
        // Left Ear
        ctx.moveTo(-10, -h/2);
        ctx.lineTo(-20, -h/2 + yTop); 
        ctx.lineTo(0, -h/2);
        // Right Ear
        ctx.moveTo(5, -h/2);
        ctx.lineTo(15, -h/2 + yTop);
        ctx.lineTo(25, -h/2);
        ctx.stroke();
    }

    // --- LAYER 5: EYE ---
    ctx.shadowBlur = 0; // Ensure clean eye rendering
    ctx.fillStyle = skin.eyeColor;
    ctx.fillRect(8, -12, 8, 8);

    // --- LAYER 6: UNIQUE DETAILS ---
    switch (skinId) {
        case 3: // INFERNO - Angry Brow
             ctx.strokeStyle = "#000"; // Dark angry brow
             ctx.lineWidth = 2;
             ctx.beginPath();
             ctx.moveTo(6, -16);
             ctx.lineTo(18, -10);
             ctx.stroke();
             break;

        case 4: // MIDAS - Crown
             ctx.strokeStyle = "#FFD700";
             ctx.lineWidth = 2;
             ctx.beginPath();
             // Crown overlay
             ctx.moveTo(-10, -h/2);
             ctx.lineTo(-15, -h/2 - 15);
             ctx.lineTo(-5, -h/2 - 5);
             ctx.lineTo(0, -h/2 - 20); // Center peak
             ctx.lineTo(5, -h/2 - 5);
             ctx.lineTo(15, -h/2 - 15);
             ctx.lineTo(10, -h/2);
             ctx.stroke();
             break;
        
        default:
             break;
    }
    
    ctx.shadowBlur = 0;
}

/* --- –°–£–©–ù–û–°–¢–ò --- */

class Cat {
    constructor(game) {
        this.game = game;
        this.w = 50;
        this.h = 40;
        this.skin = SKINS[game.selectedSkinId];
        this.reset();
    }

    updateSkin() {
        this.skin = SKINS[this.game.selectedSkinId];
    }

    reset() {
        this.x = this.game.canvas.width / 2 - 100;
        this.y = this.game.canvas.height / 2;
        this.velocity = 0;
        this.rotation = 0;
        this.timer = 0;
    }

    jump() {
        this.velocity = CONFIG.jumpForce;
        this.rotation = -20; 
        
        this.game.sound.playJump();
        for(let i=0; i<5; i++) {
            // --- OPTIMIZATION: USE POOL ---
            this.game.spawnParticle(this.x, this.y + this.h/2);
        }
    }

    update(dt) {
        this.velocity += CONFIG.gravity * dt;
        
        if (this.velocity > CONFIG.terminalVelocity) {
            this.velocity = CONFIG.terminalVelocity;
        }

        this.y += this.velocity * dt;

        if (this.velocity < 0) {
            this.rotation = Math.max(-20, this.rotation - 600 * dt);
        } else {
            this.rotation = Math.min(45, this.rotation + 200 * dt);
        }

        this.timer += dt;
        if (this.timer > 0.05) { 
            // --- OPTIMIZATION: USE POOL ---
            this.game.spawnParticle(this.x, this.y + this.h/2 + 5);
            this.timer = 0;
        }
    }

    draw(ctx) {
        ctx.save();
        // --- OPTIMIZATION: ROUND COORDS ---
        ctx.translate(~~(this.x + this.w/2), ~~(this.y + this.h/2));
        ctx.rotate(this.rotation * Math.PI / 180);

        // Call helper to draw the correct skin
        drawCatVisuals(ctx, this.w, this.h, this.skin.id, this.velocity);

        ctx.restore();
    }
}

class Obstacle {
    constructor(game, lastObstacle = null) {
        this.game = game;
        this.w = 70;
        this.x = game.canvas.width;
        this.passed = false;
        
        const minHeight = 150;
        // USE DYNAMIC HEIGHT
        const maxTop = game.canvas.height - CONFIG.gapSize - minHeight;
        
        // --- LOGIC FIX: IMPOSSIBLE JUMPS ---
        let minSafe = minHeight;
        let maxSafe = maxTop;

        if (lastObstacle) {
            // Max height change allowed based on physics approximation
            const maxDelta = 400; 
            
            minSafe = Math.max(minHeight, lastObstacle.topHeight - maxDelta);
            maxSafe = Math.min(maxTop, lastObstacle.topHeight + maxDelta);
        }

        this.topHeight = Math.floor(Math.random() * (maxSafe - minSafe + 1) + minSafe);
        this.bottomY = this.topHeight + CONFIG.gapSize;
    }
    
    update(dt) { 
        this.x -= CONFIG.speed * dt; 
    }
    
    draw(ctx) {
        // --- OPTIMIZATION: NO BLUR, FAKE GLOW, ROUND COORDS ---
        const x = ~~this.x;
        const w = ~~this.w;
        const th = ~~this.topHeight;
        const by = ~~this.bottomY;
        const gh = ~~(this.game.canvas.height - this.bottomY);

        // Fake Glow (Double Stroke)
        ctx.lineWidth = 20;
        ctx.strokeStyle = "rgba(0, 255, 0, 0.3)";
        
        // Top Pipe Glow
        ctx.beginPath();
        ctx.rect(x, -5, w, th + 5);
        ctx.stroke();

        // Bottom Pipe Glow
        ctx.beginPath();
        ctx.rect(x, by, w, gh + 5);
        ctx.stroke();

        // Main Body
        ctx.fillStyle = "#001a00";
        ctx.strokeStyle = "#0f0";
        ctx.lineWidth = 4;
        
        // Top Pipe
        ctx.fillRect(x, 0, w, th);
        ctx.strokeRect(x, -5, w, th + 5);
        
        // Top Pipe Cap
        ctx.fillStyle = "#0f0";
        ctx.fillRect(x + 10, th - 40, w - 20, 10);
        
        // Bottom Pipe
        ctx.fillStyle = "#001a00";
        ctx.fillRect(x, by, w, gh);
        ctx.strokeRect(x, by, w, gh + 5);
        
        // Bottom Pipe Cap
        ctx.fillStyle = "#0f0";
        ctx.fillRect(x + 10, by + 30, w - 20, 10);
    }
}

class Particle {
    constructor() {
        this.active = false;
    }

    activate(x, y, skinId) {
        this.x = x;
        this.y = y;
        this.skinId = skinId;
        this.life = 1.0;
        this.size = Math.random() * 8 + 4;
        
        // Default physics
        this.vx = (Math.random() - 0.5) * 300 - 300; 
        this.vy = (Math.random() - 0.5) * 300;
        this.decay = 2.5;

        // Customization based on Skin
        switch (skinId) {
            case 1: // PLASMA
                this.color = Math.random() > 0.5 ? "#ff00ff" : "#ffccff";
                this.shape = 'square';
                break;
            case 2: // PHANTOM
                this.color = Math.random() > 0.5 ? "#00ffff" : "#e0ffff";
                this.shape = 'rect';
                break;
            case 3: // INFERNO
                this.color = Math.random() > 0.5 ? "#FF4500" : "#FFFF00";
                this.shape = 'rect';
                this.size = Math.random() * 6 + 2; 
                this.decay = 3.0; 
                break;
            case 4: // MIDAS
                this.color = Math.random() > 0.5 ? "#ffd700" : "#ffffff";
                this.shape = 'circle';
                this.decay = 2.0;
                break;
            case 0: 
            default:
                this.color = Math.random() > 0.5 ? "#00ffff" : "#0099ff";
                this.shape = 'rect'; 
                break;
        }
        
        this.active = true;
    }
    
    update(dt) {
        if (!this.active) return;
        this.x += this.vx * dt;
        this.y += this.vy * dt;
        this.life -= this.decay * dt; 
        this.size *= (1 - 2 * dt);
        if (this.life <= 0) this.active = false;
    }
    
    draw(ctx) {
        if (!this.active) return;
        ctx.globalAlpha = Math.max(0, this.life);
        ctx.fillStyle = this.color;
        ctx.beginPath();
        
        const s = ~~this.size;
        const x = ~~this.x;
        const y = ~~this.y;

        if (this.shape === 'circle') {
            ctx.arc(x, y, s/2, 0, Math.PI * 2);
            ctx.fill();
        } else if (this.shape === 'square') {
            ctx.fillRect(x, y, s, s);
        } else {
            ctx.rect(x, y, s, s);
            ctx.fill();
        }
        
        ctx.globalAlpha = 1.0;
    }
}

class Background {
    constructor(game) {
        this.game = game;
        this.bgX = 0;
        this.buildings = [];
        for(let i=0; i<20; i++) {
            this.buildings.push({
                x: i * 80,
                w: 60 + Math.random() * 40,
                h: 200 + Math.random() * 600,
                color: `rgba(20, 0, 50, ${0.3 + Math.random() * 0.4})`
            });
        }
    }
    
    update(dt) {
        if (this.game.state === STATE.PLAYING) {
            this.bgX -= (CONFIG.speed * 0.1) * dt; 
            if (this.bgX <= -CONFIG.logicalWidth) this.bgX = 0;
        }
    }
    
    draw(ctx) {
        ctx.strokeStyle = "rgba(100, 0, 255, 0.1)";
        ctx.lineWidth = 2;
        const gridSize = 80;
        const offset = ~~this.bgX % gridSize;
        for (let x = offset; x < CONFIG.logicalWidth; x += gridSize) {
            ctx.beginPath();
            ctx.moveTo(~~x, 0);
            // Use game canvas height
            ctx.lineTo(~~x, this.game.canvas.height);
            ctx.stroke();
        }
        for (let y = 0; y < this.game.canvas.height; y += gridSize) {
            ctx.beginPath();
            ctx.moveTo(0, ~~y);
            ctx.lineTo(CONFIG.logicalWidth, ~~y);
            ctx.stroke();
        }
        ctx.save();
        ctx.translate(~~this.bgX, 0);
        for(let j=0; j<2; j++) {
            const shift = j * 1600;
            this.buildings.forEach(b => {
                ctx.fillStyle = b.color;
                // Use game canvas height
                ctx.fillRect(~~(b.x + shift), ~~(this.game.canvas.height - b.h), ~~b.w, ~~b.h);
                ctx.fillStyle = "rgba(0, 255, 255, 0.2)";
                for(let wy = this.game.canvas.height - b.h + 20; wy < this.game.canvas.height; wy += 40) {
                       if(Math.random() > 0.3) ctx.fillRect(~~(b.x + shift + 10), ~~wy, ~~(b.w - 20), 20);
                }
            });
        }
        ctx.restore();
    }
}

/**
 * INITIALIZATION
 */
let gameInstance = null;

function initYandex() {
    YaGames.init().then(ysdk_instance => {
        console.log('Yandex SDK Initialized');
        ysdk = ysdk_instance;
        
        // Device check
        if (ysdk.deviceInfo.type === 'mobile' || ysdk.deviceInfo.type === 'tablet') {
            document.body.classList.add('mobile-device');
        }
        
        // Report ready state
        ysdk.features.LoadingAPI.ready();

        // Update language based on SDK environment
        if (gameInstance && gameInstance.langManager) {
            gameInstance.langManager.init();
            gameInstance.langManager.updateButtons();
        }
    }).catch(console.error);
}

window.onload = () => {
    gameInstance = new Game();
    initYandex();
};

</script>
</body>
</html>
