<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>–¢–µ–º–Ω—ã–π –†—ã—Ü–∞—Ä—å: –í–µ—á–Ω—ã–π –ü—É—Ç—å</title>
    
    <!-- Yandex Games SDK (Updated for ZIP archive requirement) -->
    <script src="/sdk.js"></script>
    
    <!-- 
        LICENSE & COPYRIGHT INFO:
        - Code: Procedurally generated / Custom implementation.
        - Assets: All graphics are drawn via HTML5 Canvas API (no external images).
        - Audio: Generated via Web Audio API (no external MP3/WAV).
        - Fonts: Standard System Fonts used (Georgia/Impact stack).
        - Compliance: Meets Yandex Games requirements.
    -->

    <style>
        /* 1. GLOBAL RESET & MOBILE OPTIMIZATION */
        * {
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            outline: none;
        }

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background-color: #050505;
            overflow: hidden; /* Prevent scroll bouncing */
            /* FONT: Safe system serif stack for Fantasy vibe */
            font-family: 'Georgia', 'Times New Roman', Times, serif;
            user-select: none;
            -webkit-touch-callout: none;
            touch-action: none;
        }

        /* 2. BACKGROUND WRAPPER */
        #bg-wrapper {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(to bottom, #1a0b2e, #000000);
            filter: blur(20px);
            z-index: 0;
            opacity: 0.8;
            transform: scale(1.1);
        }

        /* 3. GAME CONTAINER */
        #game-container {
            position: relative;
            z-index: 1;
            background-color: #000;
            overflow: hidden;
            box-shadow: 0 0 50px rgba(138, 43, 226, 0.2);
            touch-action: none; /* Ensure no gestures inside game */
            
            /* DESKTOP: Portrait 9:16 */
            height: 100vh;
            aspect-ratio: 9 / 16;
            margin: 0 auto;
            border-left: 1px solid #333;
            border-right: 1px solid #333;
        }

        /* MOBILE / TABLET OVERRIDE: Full width if screen is narrower than 9:16 */
        @media screen and (max-aspect-ratio: 9/16) {
            #game-container {
                width: 100vw;
                height: 100vh;
                margin: 0;
                border: none;
            }
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            touch-action: none; /* Critical for canvas inputs */
        }

        /* 4. UI LAYER */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        .screen {
            position: absolute;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
            transition: opacity 0.3s;
            opacity: 0;
            pointer-events: none;
            background-image: radial-gradient(circle at center, transparent 0%, #000 90%);
            z-index: 20;
            /* FIX: Prevent overlap on very small screens via scroll */
            overflow-y: auto; 
            padding: 20px 0;
        }

        .screen.active {
            opacity: 1;
            pointer-events: auto;
        }

        /* ROTATE DEVICE SCREEN (Hidden by default) */
        #screen-rotate {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #000;
            z-index: 99999;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #fff;
            text-align: center;
        }

        #screen-rotate span {
            font-size: 60px;
            margin-bottom: 20px;
            animation: rotate-icon 2s infinite ease-in-out;
        }

        @keyframes rotate-icon {
            0% { transform: rotate(0deg); }
            50% { transform: rotate(-90deg); }
            100% { transform: rotate(0deg); }
        }

        /* Only show rotate screen on MOBILE LANDSCAPE */
        @media screen and (orientation: landscape) and (max-height: 600px) {
            #screen-rotate {
                display: flex !important;
            }
        }

        /* Typography - Gothic Style */
        h1 {
            color: #b30000;
            font-family: 'Impact', 'Arial Black', 'Charcoal', sans-serif;
            font-size: 58px; 
            margin-bottom: 30px; /* More spacing for main title */
            text-transform: uppercase;
            letter-spacing: 5px;
            text-shadow: 4px 4px 0px #000, 0 0 20px rgba(179, 0, 0, 0.6);
            text-align: center;
            line-height: 1.1;
            max-width: 95%;
            font-weight: 900;
        }

        /* Game Over Title - Smaller, cleaner */
        .gameover-title {
            font-size: 48px;
            margin-bottom: 10px;
            color: #d1d1d1;
            text-shadow: 2px 2px 0 #000;
        }

        h2 {
            color: #d1d1d1;
            font-family: 'Georgia', 'Times New Roman', serif;
            font-weight: bold;
            letter-spacing: 2px;
            font-size: 32px;
            margin-bottom: 20px;
            text-transform: uppercase;
            border-bottom: 1px solid #5a1a1a;
            padding-bottom: 10px;
        }

        /* Score Display in Game Over - Compact */
        .result-box {
            background: rgba(20, 10, 10, 0.8);
            border: 1px solid #5a1a1a;
            padding: 20px 40px;
            border-radius: 8px;
            margin-bottom: 20px;
            text-align: center;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }

        .score-display {
            font-family: 'Impact', 'Arial Black', sans-serif;
            font-size: 60px; /* Reduced from 80 */
            color: #b30000;
            margin: 5px 0;
            text-shadow: 2px 2px 0 #000;
            letter-spacing: 2px;
        }

        .best-score-display {
            color: #888;
            font-size: 18px;
            font-family: 'Georgia', 'Times New Roman', serif;
            text-transform: uppercase;
        }

        /* Buttons */
        .btn {
            background: linear-gradient(180deg, #2b0a0a, #000000);
            border: 2px solid #5a1a1a;
            color: #d1d1d1;
            padding: 12px 30px;
            font-size: 20px; /* Slightly smaller for structure */
            font-family: 'Georgia', 'Times New Roman', serif;
            font-weight: 700;
            letter-spacing: 1px;
            cursor: pointer;
            margin: 8px;
            min-width: 200px;
            min-height: 50px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.8);
            transition: all 0.2s;
            text-transform: uppercase;
            position: relative;
            overflow: hidden;
            white-space: nowrap; 
            border-radius: 4px;
        }

        .btn:hover {
            border-color: #b30000;
            color: #fff;
            box-shadow: 0 0 15px rgba(179, 0, 0, 0.4);
        }

        .btn:active {
            transform: scale(0.96);
        }

        .btn-secondary {
            background: linear-gradient(180deg, #1a1a2e, #000000);
            border-color: #2c3e50;
            color: #aec6cf;
        }
        
        .btn-menu {
            background: linear-gradient(180deg, #1a1a1a, #000000);
            border-color: #444;
            color: #aaa;
        }

        /* HUD */
        #hud {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 20px; /* Fallback */
            padding-top: max(20px, env(safe-area-inset-top));
            padding-left: max(20px, env(safe-area-inset-left));
            padding-right: max(20px, env(safe-area-inset-right));
            
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            pointer-events: none;
            z-index: 10;
        }

        .hud-scores-container {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
        }

        .hud-score {
            color: #d1d1d1;
            font-size: 32px;
            font-family: 'Impact', 'Arial Black', sans-serif;
            text-shadow: 2px 2px 0 #000;
            letter-spacing: 2px;
        }

        .hud-best {
            color: #888;
            font-size: 18px;
            margin-top: 5px;
            font-family: 'Georgia', 'Times New Roman', serif;
        }

        .btn-icon {
            pointer-events: auto;
            background: rgba(0,0,0,0.6);
            border: 2px solid #5a1a1a;
            color: #ccc;
            width: 50px;
            height: 50px;
            border-radius: 10px; 
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            font-size: 24px;
            transition: all 0.2s;
            box-shadow: 0 4px 10px rgba(0,0,0,0.8);
        }

        .btn-icon:hover {
            border-color: #b30000;
            color: white;
        }

        /* Settings Screen Layout */
        #screen-settings .menu-container {
            background: rgba(10, 5, 5, 0.95);
            border: 2px solid #5a1a1a;
            padding: 30px;
            border-radius: 5px;
            display: flex;
            flex-direction: column;
            align-items: center;
            box-shadow: 0 0 30px rgba(0,0,0,1);
            min-width: 280px;
        }

        .loading-overlay {
            background: #000;
            z-index: 999;
        }

        /* FIX: Adaptive Scaling for Small Landscape Screens */
        @media screen and (max-height: 500px) {
            h1 { font-size: 32px !important; margin-bottom: 10px !important; }
            h2 { font-size: 20px !important; margin-bottom: 10px !important; }
            .score-display { font-size: 40px !important; }
            
            .btn {
                padding: 8px 20px !important;
                font-size: 16px !important;
                min-height: 40px !important;
                margin: 4px !important;
                min-width: 160px !important;
            }
            
            #screen-settings .menu-container {
                padding: 15px !important;
                min-width: 240px !important;
            }
            
            .result-box {
                padding: 10px 20px !important;
                margin-bottom: 10px !important;
            }

            .screen {
                justify-content: flex-start; 
                padding-top: 20px;
            }
        }
    </style>
</head>
<!-- Added oncontextmenu and ondragstart to body as requested -->
<body oncontextmenu="return false;" ondragstart="return false;">

    <div id="bg-wrapper"></div>

    <div id="game-container">
        <canvas id="gameCanvas"></canvas>

        <div id="hud">
            <div class="hud-scores-container">
                <div class="hud-score"><span id="lbl-score">SOULS</span>: <span id="scoreVal">0</span></div>
                <div class="hud-best"><span id="lbl-best">BEST</span>: <span id="bestVal">0</span></div>
            </div>
            <!-- Settings Toggle Button -->
            <div class="btn-icon" id="btnSettings">‚öôÔ∏è</div>
        </div>

        <div id="ui-layer">
            <!-- Loading - Removed Text as requested -->
            <div id="screen-loading" class="screen active loading-overlay">
            </div>

            <!-- Start Screen -->
            <div id="screen-start" class="screen">
                <h1 id="txt-title">DARK KNIGHT:<br>ETERNAL PATH</h1>
                <button class="btn" id="btnPlay">BEGIN JOURNEY</button>
                <button class="btn btn-menu" id="btnMenuSettings">SETTINGS</button>
            </div>

            <!-- Settings / Pause Screen -->
            <div id="screen-settings" class="screen">
                <div class="menu-container">
                    <h2 id="txt-settings-title">PAUSED</h2>
                    <button class="btn" id="btnResume">RESUME</button>
                    <button class="btn btn-secondary" id="btnLangToggle">LANG: EN</button>
                    <button class="btn btn-secondary" id="btnSoundToggle">SOUND: ON</button>
                    <button class="btn btn-secondary" id="btnExit">EXIT</button>
                </div>
            </div>

            <!-- Game Over Screen -->
            <div id="screen-gameover" class="screen">
                <h1 id="txt-gameover" class="gameover-title">YOU DIED</h1>
                
                <div class="result-box">
                    <div class="score-display"><span id="finalScore">0</span></div>
                    <div class="best-score-display"><span id="lbl-best-over">BEST</span>: <span id="finalBest">0</span></div>
                </div>
                
                <button class="btn" id="btnRestart">TRY AGAIN</button>
                <button class="btn btn-secondary" id="btnRevive">
                    üé¨ <span id="txt-revive">RESURRECT</span>
                </button>
                <button class="btn btn-menu" id="btnHome">MENU</button>
            </div>
        </div>
        
        <!-- Rotate Device Overlay -->
        <div id="screen-rotate">
            <span>üì±</span>
            <p id="txt-rotate">PLEASE ROTATE DEVICE</p>
        </div>
    </div>

<script>
/**
 * ==========================================
 * 1. LOCALIZATION
 * ==========================================
 */
const TRANSLATIONS = {
    en: {
        loading: "SUMMONING...",
        title: "DARK KNIGHT:\nETERNAL PATH",
        play: "BEGIN JOURNEY",
        gameover: "YOU PERISHED",
        paused: "PAUSED",
        settings: "SETTINGS",
        resume: "RESUME",
        back: "BACK",
        soundOn: "SOUND: ON",
        soundOff: "SOUND: OFF",
        langLabel: "LANG: EN",
        exit: "EXIT TO MENU",
        menu: "MAIN MENU",
        settingsBtn: "SETTINGS",
        restart: "TRY AGAIN",
        revive: "AD: RESURRECT",
        score: "SOULS",
        best: "BEST",
        rotate: "PLEASE ROTATE DEVICE"
    },
    ru: {
        loading: "–ü–†–ò–ó–´–í...",
        title: "–¢–ï–ú–ù–´–ô –†–´–¶–ê–†–¨:\n–í–ï–ß–ù–´–ô –ü–£–¢–¨",
        play: "–ù–ê–ß–ê–¢–¨ –ü–£–¢–¨",
        gameover: "–í–´ –ü–û–ì–ò–ë–õ–ò",
        paused: "–ü–ê–£–ó–ê",
        settings: "–ù–ê–°–¢–†–û–ô–ö–ò",
        resume: "–ü–†–û–î–û–õ–ñ–ò–¢–¨",
        back: "–ù–ê–ó–ê–î",
        soundOn: "–ó–í–£–ö: –í–ö–õ",
        soundOff: "–ó–í–£–ö: –í–´–ö–õ",
        langLabel: "–Ø–ó–´–ö: RU",
        exit: "–í –ú–ï–ù–Æ",
        menu: "–í –ì–õ–ê–í–ù–û–ï –ú–ï–ù–Æ",
        settingsBtn: "–ù–ê–°–¢–†–û–ô–ö–ò",
        restart: "–ï–©–ï –†–ê–ó",
        revive: "–†–ï–ö–õ–ê–ú–ê: –í–û–°–ö–†–ï–°–ù–£–¢–¨",
        score: "–î–£–®–ò",
        best: "–†–ï–ö–û–†–î",
        rotate: "–ü–û–í–ï–†–ù–ò–¢–ï –£–°–¢–†–û–ô–°–¢–í–û"
    }
};

/**
 * ==========================================
 * 2. AUDIO SYSTEM
 * ==========================================
 */
class SoundManager {
    constructor() {
        this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        this.masterGain = this.ctx.createGain();
        this.masterGain.connect(this.ctx.destination);
        
        // Load mute state
        this.muted = localStorage.getItem('grim-path-muted') === 'true';
        this.updateGain();
    }

    setMute(isMuted) {
        this.muted = isMuted;
        localStorage.setItem('grim-path-muted', isMuted);
        this.updateGain();
        
        if (this.ctx.state === 'suspended' && !this.muted) {
            this.ctx.resume();
        }
        return this.muted;
    }

    updateGain() {
        this.masterGain.gain.setValueAtTime(this.muted ? 0 : 1, this.ctx.currentTime);
    }

    playJump() {
        if (this.muted) return;
        this._playTone(100, 'triangle', 0.15, -12, true);
    }

    playCrash() {
        if (this.muted) return;
        this._playTone(120, 'triangle', 0.6, -5, true, 0.01); 
        setTimeout(() => {
             this._playTone(60, 'sine', 0.8, -3, true, 0.01);
        }, 50);
    }

    playStep() {
        if (this.muted) return;
        this._playTone(80, 'triangle', 0.05, -20);
    }

    playScore() {
        if (this.muted) return;
        this._playTone(600, 'sine', 0.1, -15);
        setTimeout(() => this._playTone(800, 'sine', 0.2, -15), 100);
    }

    playClick() {
        if (this.muted) return;
        this._playTone(400, 'triangle', 0.05, -12);
    }

    // New Sound for Speed Burst
    playWhoosh() {
        if (this.muted) return;
        // White noise-ish effect via low tri
        this._playTone(150, 'sawtooth', 0.2, -18, true);
    }

    _playTone(freq, type, duration, volDecibels, slide = false, rampEnd = 0.001) {
        if (this.ctx.state === 'suspended') this.ctx.resume();
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        
        osc.type = type;
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        if (slide) {
            if (rampEnd < 1) {
                 osc.frequency.exponentialRampToValueAtTime(Math.max(10, freq * 0.2), this.ctx.currentTime + duration);
            } else {
                 osc.frequency.exponentialRampToValueAtTime(freq * 3, this.ctx.currentTime + duration);
            }
        }
        
        const vol = Math.pow(10, volDecibels / 20);
        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + duration);

        osc.connect(gain);
        gain.connect(this.masterGain);
        
        osc.start();
        osc.stop(this.ctx.currentTime + duration);
    }
}

/**
 * ==========================================
 * 3. YANDEX SDK & TRANSLATION MANAGER
 * ==========================================
 */
class YandexManager {
    constructor(gameInstance, ysdk, initialLang) {
        this.game = gameInstance;
        this.ysdk = ysdk;
        this.isMock = !ysdk;
        
        // Use the passed language or fallback to saved/en
        this.lang = localStorage.getItem('grim-path-lang') || initialLang || 'en';
        
        this.applyTranslations();
    }

    setLanguage(lang) {
        this.lang = lang;
        localStorage.setItem('grim-path-lang', lang);
        this.applyTranslations();
    }

    toggleLanguage() {
        const newLang = this.lang === 'en' ? 'ru' : 'en';
        this.setLanguage(newLang);
    }

    // init() REMOVED per requirements. Logic moved to window.onload

    gameplayStart() {
        if (this.ysdk && this.ysdk.features.GameplayAPI) {
            this.ysdk.features.GameplayAPI.start();
        }
    }

    gameplayStop() {
        if (this.ysdk && this.ysdk.features.GameplayAPI) {
            this.ysdk.features.GameplayAPI.stop();
        }
    }

    applyTranslations() {
        const t = TRANSLATIONS[this.lang];
        if (!t) return; 
        
        const loadEl = document.getElementById('txt-loading');
        // If element exists and we have text, we set it. 
        // NOTE: User removed the h1 tag, so this check avoids errors if ID is missing.
        // But the ID txt-loading was on the H1 which is now gone. 
        // We can safely ignore if element is missing.
        if (loadEl) loadEl.innerText = t.loading;

        document.getElementById('txt-title').innerText = t.title;
        document.getElementById('btnPlay').innerText = t.play;
        document.getElementById('btnMenuSettings').innerText = t.settingsBtn;
        
        document.getElementById('txt-gameover').innerText = t.gameover;
        document.getElementById('btnRestart').innerText = t.restart;
        document.getElementById('txt-revive').innerText = t.revive;
        document.getElementById('btnHome').innerText = t.menu;
        
        document.getElementById('lbl-score').innerText = t.score;
        document.getElementById('lbl-best').innerText = t.best;
        document.getElementById('lbl-best-over').innerText = t.best;
        
        document.getElementById('btnExit').innerText = t.exit;
        document.getElementById('btnLangToggle').innerText = t.langLabel;
        document.getElementById('txt-rotate').innerText = t.rotate;
        
        this.updateSoundBtnText();
    }

    updateSoundBtnText() {
        const t = TRANSLATIONS[this.lang];
        const btn = document.getElementById('btnSoundToggle');
        btn.innerText = this.game.sound.muted ? t.soundOff : t.soundOn;
    }

    showInterstitial(cb) {
        this.gameplayStop();

        if (this.isMock) {
            if (cb) cb();
            return;
        }
        
        this.ysdk.adv.showFullscreenAdv({ 
            callbacks: { 
                onClose: (wasShown) => {
                    if (cb) cb();
                }, 
                onError: (error) => {
                    console.error("Ad Error:", error);
                    if (cb) cb();
                } 
            } 
        });
    }

    showRewarded(cb) {
        this.gameplayStop();

        // 1. MOCK MODE (Strict: Confirm Dialog)
        if (this.isMock) {
            const confirmed = confirm("–¢–µ—Å—Ç–æ–≤–∞—è —Ä–µ–∫–ª–∞–º–∞: –ü–æ—Å–º–æ—Ç—Ä–µ—Ç—å –≤–∏–¥–µ–æ –∑–∞ –Ω–∞–≥—Ä–∞–¥—É?");
            if (confirmed) {
                if (cb) cb();
            }
            // If cancelled, do nothing (stay in Game Over)
            return;
        }

        // 2. SDK MODE (Strict: Check onRewarded)
        let rewardGranted = false;

        this.ysdk.adv.showRewardedVideo({
            callbacks: {
                onOpen: () => {
                    if (this.game.sound.ctx.state === 'running') {
                        this.game.sound.masterGain.gain.setValueAtTime(0, this.game.sound.ctx.currentTime);
                    }
                },
                onRewarded: () => {
                    rewardGranted = true;
                },
                onClose: () => {
                    this.game.sound.updateGain();
                    if (rewardGranted && cb) {
                        cb();
                    }
                    // If not rewarded, do nothing (stay in Game Over)
                },
                onError: (e) => {
                    console.error("Rewarded Error:", e);
                    this.game.sound.updateGain();
                    // Alert user on error
                    alert("–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å —Ä–µ–∫–ª–∞–º—É. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.");
                }
            }
        });
    }
}

/**
 * ==========================================
 * 4. PARALLAX
 * ==========================================
 */
class ParallaxLayer {
    constructor(gameWidth, gameHeight, speedModifier, type) {
        this.width = gameWidth;
        this.height = gameHeight;
        this.speedModifier = speedModifier;
        this.x = 0;
        this.canvas = document.createElement('canvas');
        this.canvas.width = gameWidth;
        this.canvas.height = gameHeight;
        this.ctx = this.canvas.getContext('2d');
        this.generateAsset(type);
    }

    generateAsset(type) {
        const ctx = this.ctx;
        const w = this.width;
        const h = this.height;
        ctx.clearRect(0, 0, w, h);

        if (type === 'mountains') {
            ctx.fillStyle = '#12051c'; 
            ctx.beginPath();
            ctx.moveTo(0, h);
            for (let i = 0; i <= w; i += 20) {
                const y = h - 150 - Math.random() * 100 - (Math.sin(i/100)*50);
                ctx.lineTo(i, y);
            }
            ctx.lineTo(w, h);
            ctx.fill();
        } 
        else if (type === 'forest') {
            ctx.fillStyle = '#1e0b2e';
            const groundLevel = h - 80;
            ctx.fillRect(0, groundLevel, w, h - groundLevel);
            for (let i = 0; i < w; i += 60 + Math.random() * 60) {
                const treeH = 100 + Math.random() * 80;
                const treeW = 10 + Math.random() * 10;
                ctx.fillRect(i, groundLevel - treeH, treeW, treeH);
                ctx.lineWidth = 4;
                ctx.strokeStyle = '#1e0b2e';
                ctx.beginPath();
                ctx.moveTo(i + treeW/2, groundLevel - treeH + 30);
                ctx.lineTo(i - 20, groundLevel - treeH);
                ctx.stroke();
            }
        }
    }

    update(gameSpeed, dt) {
        this.x -= gameSpeed * this.speedModifier * dt;
        if (this.x <= -this.width) this.x = 0;
    }

    draw(mainCtx) {
        // OPTIMIZATION: Use bitwise OR for integer coords to prevent sub-pixel blurring/tearing
        mainCtx.drawImage(this.canvas, (this.x | 0), 0);
        mainCtx.drawImage(this.canvas, (this.x + this.width | 0), 0);
    }
}

/**
 * ==========================================
 * 5. GAME ENGINE & STATE MACHINE
 * ==========================================
 */
class Game {
    constructor(ysdk, initialLang) {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        
        // STATES: LOADING, MENU, PLAYING, PAUSED, GAMEOVER
        this.state = 'LOADING'; 
        this.menuContext = false; 
        
        this.width = 0;
        this.height = 0;
        this.shakeIntensity = 0;
        
        // Systems
        this.sound = new SoundManager();
        // Pass ysdk and detected language to manager
        this.yandex = new YandexManager(this, ysdk, initialLang);
        
        // Performance
        this.lastTime = 0;
        this.isTabActive = true;

        // Scores
        this.score = 0;
        this.bestScore = parseInt(localStorage.getItem('grim-path-best')) || 0;
        document.getElementById('bestVal').innerText = this.bestScore;
        
        // Entities
        this.player = {
            x: 100, y: 0, width: 40, height: 60, 
            dy: 0, jumpForce: 15, grounded: false, 
            runFrame: 0, capeFrame: 0
        };
        
        this.obstacles = [];
        this.particles = [];
        this.parallaxLayers = [];
        this.score = 0;

        // NEW PHYSICS: Separate Base Speed and Current Speed
        this.baseSpeed = 5.5; 
        this.currentSpeed = 5.5;
        this.speedMultiplier = 1.0; // For bursts

        this.gravity = 0.65; 
        this.spawnTimer = 0; 
        this.stepTimer = 0; 

        // New Logic: Cooldown based bursts
        this.burstCount = 0;
        this.burstCooldownEnd = 0;
        
        // Caching Gradients
        this.bgGradient = null;
        this.vignetteGradient = null;

        // Bindings
        this.loop = this.loop.bind(this);
        this.resize = this.resize.bind(this);
        this.handleInput = this.handleInput.bind(this);

        // Events
        window.addEventListener('resize', this.resize);
        this.resize();

        // Control Inputs
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space' || e.code === 'ArrowUp') {
                e.preventDefault(); 
                this.handleInput();
            }
            if (e.code === 'Escape') this.togglePause();
        });
        
        const inputHandler = (e) => {
            if (e.target.closest('.btn') || e.target.closest('.btn-icon')) {
                if (e.type === 'pointerdown') this.sound.playClick();
                return;
            }
            if (e.cancelable && e.type === 'touchstart') e.preventDefault();
            this.handleInput();
        };

        document.addEventListener('pointerdown', inputHandler, { passive: false });

        this.setupUI();
        this.init();
    }

    setupUI() {
        // Main Menu (Start)
        document.getElementById('btnPlay').onclick = () => {
            this.enterFullscreen(); 
            this.yandex.showInterstitial(() => {
                this.setState('PLAYING');
            });
        };

        // Main Menu Settings
        document.getElementById('btnMenuSettings').onclick = () => {
            this.menuContext = true; 
            this.setState('PAUSED');
        };

        // Game Over Buttons
        document.getElementById('btnRestart').onclick = () => {
            this.yandex.showInterstitial(() => this.restartGame());
        };
        document.getElementById('btnRevive').onclick = () => {
            this.yandex.showRewarded(() => this.reviveGame());
        };
        document.getElementById('btnHome').onclick = () => {
            this.quitToMenu();
        };

        // HUD Settings
        const btnSettings = document.getElementById('btnSettings');
        btnSettings.addEventListener('click', (e) => {
            e.stopPropagation(); 
            this.menuContext = false; 
            this.togglePause();
        });
        btnSettings.addEventListener('touchstart', (e) => {
             e.stopPropagation(); 
             e.preventDefault();
             this.menuContext = false;
             this.togglePause();
        });

        // Settings Screen Buttons
        document.getElementById('btnResume').onclick = () => {
            if (this.menuContext) {
                this.setState('MENU');
            } else {
                this.togglePause();
            }
        };
        
        document.getElementById('btnLangToggle').onclick = () => {
            this.yandex.toggleLanguage();
            this.updateSettingsLabels(); 
        };

        document.getElementById('btnSoundToggle').onclick = () => {
            const newState = !this.sound.muted;
            this.sound.setMute(newState);
            this.yandex.updateSoundBtnText();
        };

        document.getElementById('btnExit').onclick = () => this.quitToMenu();

        // Page Visibility
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                this.sound.ctx.suspend();
                if (this.state === 'PLAYING') {
                    this.menuContext = false;
                    this.setState('PAUSED'); 
                }
                this.isTabActive = false; 
            } else {
                this.sound.ctx.resume();
                this.isTabActive = true;
                this.lastTime = performance.now(); 
                requestAnimationFrame(this.loop);
            }
        });
    }

    updateSettingsLabels() {
        const t = TRANSLATIONS[this.yandex.lang];
        const title = document.getElementById('txt-settings-title');
        const resumeBtn = document.getElementById('btnResume');
        const exitBtn = document.getElementById('btnExit');

        if (this.menuContext) {
            title.innerText = t.settings;
            resumeBtn.innerText = t.back;
            exitBtn.style.display = 'none';
        } else {
            title.innerText = t.paused;
            resumeBtn.innerText = t.resume;
            exitBtn.style.display = 'inline-block';
            exitBtn.innerText = t.exit;
        }
    }

    enterFullscreen() {
        const elem = document.documentElement;
        if (elem.requestFullscreen) {
            elem.requestFullscreen().catch(err => console.log(err));
        } else if (elem.webkitRequestFullscreen) {
            elem.webkitRequestFullscreen();
        } else if (elem.msRequestFullscreen) {
            elem.msRequestFullscreen();
        }
    }

    // Removed async Yandex init from here
    init() {
        requestAnimationFrame(this.loop);
        this.initParallax();
        this.setState('MENU');
        document.getElementById('screen-loading').classList.remove('active');
    }

    setState(newState) {
        const prevState = this.state;
        this.state = newState;
        document.querySelectorAll('.screen').forEach(el => el.classList.remove('active'));

        if (newState === 'PLAYING') {
            this.yandex.gameplayStart();
        } else if (prevState === 'PLAYING' && newState !== 'PLAYING') {
            this.yandex.gameplayStop();
        }

        if (newState === 'MENU') {
            document.getElementById('screen-start').classList.add('active');
            document.getElementById('btnSettings').style.display = 'none'; 
            this.score = 0;
            this.resetEntities();
        } 
        else if (newState === 'PLAYING') {
            document.getElementById('btnSettings').style.display = 'flex';
            if (this.score === 0) this.resetEntities();
            this.lastTime = performance.now(); 
        }
        else if (newState === 'PAUSED') {
            document.getElementById('screen-settings').classList.add('active');
            this.updateSettingsLabels();
        }
        else if (newState === 'GAMEOVER') {
             document.getElementById('screen-gameover').classList.add('active');
             document.getElementById('btnSettings').style.display = 'none';
             this.checkBestScore();
        }
    }

    checkBestScore() {
        if (this.score > this.bestScore) {
            this.bestScore = Math.floor(this.score);
            localStorage.setItem('grim-path-best', this.bestScore);
            document.getElementById('bestVal').innerText = this.bestScore;
        }
        document.getElementById('finalBest').innerText = this.bestScore;
    }

    togglePause() {
        if (this.state === 'PLAYING') {
            this.setState('PAUSED');
        } else if (this.state === 'PAUSED') {
            this.setState('PLAYING');
        }
    }

    quitToMenu() {
        this.yandex.showInterstitial(() => {
            this.setState('MENU');
        });
    }

    restartGame() {
        this.resetEntities();
        this.setState('PLAYING');
    }

    reviveGame() {
        this.player.y = this.groundY - this.player.height;
        this.player.dy = 0;
        this.obstacles = [];
        this.spawnTimer = 0;
        this.shakeIntensity = 0;
        document.getElementById('btnRevive').style.display = 'none'; 
        this.setState('PLAYING');
    }

    resetEntities() {
        this.obstacles = [];
        this.particles = [];
        this.player.y = this.groundY - this.player.height;
        this.player.dy = 0;
        this.score = 0;
        this.baseSpeed = 5.5;
        this.currentSpeed = 5.5;
        this.speedMultiplier = 1.0;
        this.gravity = 0.65;
        this.player.x = 100; 
        this.spawnTimer = 0;
        this.stepTimer = 0;
        
        // Reset Cooldown logic
        this.burstCount = 0;
        this.burstCooldownEnd = 0;

        document.getElementById('btnRevive').style.display = 'inline-block';
    }

    initParallax() {
        this.parallaxLayers = [
            new ParallaxLayer(this.width, this.height, 0.2, 'mountains'),
            new ParallaxLayer(this.width, this.height, 0.6, 'forest')
        ];
    }

    resize() {
        const container = document.getElementById('game-container');
        this.canvas.width = container.clientWidth;
        this.canvas.height = container.clientHeight;
        this.width = this.canvas.width;
        this.height = this.canvas.height;
        this.groundY = this.height - 80;
        
        this.initParallax();

        // OPTIMIZATION: Cache gradients on resize instead of every frame
        this.bgGradient = this.ctx.createLinearGradient(0, 0, 0, this.height);
        this.bgGradient.addColorStop(0, '#050010');
        this.bgGradient.addColorStop(1, '#240b36');

        this.vignetteGradient = this.ctx.createRadialGradient(
            this.width/2, this.height/2, this.height/3, 
            this.width/2, this.height/2, this.height
        );
        this.vignetteGradient.addColorStop(0, 'transparent');
        this.vignetteGradient.addColorStop(1, 'rgba(0,0,0,0.7)');

        if (this.state === 'MENU' || this.state === 'LOADING') {
             this.player.y = this.groundY - this.player.height;
        }
    }

    handleInput() {
        if (this.state !== 'PLAYING') return;

        if (this.player.grounded) {
            this.player.dy = -this.player.jumpForce;
            this.player.grounded = false;
            this.sound.playJump();
            this.createParticles(this.player.x + 20, this.player.y + this.player.height, 10, '#555', 'dust');
        }
    }

    createParticles(x, y, count, color, type = 'spark') {
        for (let i = 0; i < count; i++) {
            this.particles.push({
                x: x, y: y,
                vx: (Math.random() - 0.5) * (type === 'death' ? 10 : 3),
                vy: (Math.random() - 1) * (type === 'death' ? 10 : 3),
                life: 1.0,
                color: color,
                type: type,
                size: Math.random() * (type === 'death' ? 6 : 3)
            });
        }
    }

    // Helper: Linear Interpolation for Smooth Speed
    lerp(start, end, amt) {
        return (1 - amt) * start + amt * end;
    }

    update(dt) {
        if (this.state === 'PAUSED') return;

        // Calculate current speed with burst multiplier
        // Speed Multiplier slowly decays back to 1.0
        this.speedMultiplier = this.lerp(this.speedMultiplier, 1.0, 0.05 * dt);
        this.currentSpeed = this.baseSpeed * this.speedMultiplier;

        if (this.state === 'PLAYING' || this.state === 'MENU') {
            const scrollSpeed = (this.state === 'MENU') ? 2 : this.currentSpeed;
            this.parallaxLayers.forEach(layer => layer.update(scrollSpeed, dt));
        }

        if (this.state !== 'PLAYING') return;

        // Player Physics
        this.player.dy += this.gravity * dt;
        this.player.y += this.player.dy * dt;

        // Ground Collision
        if (this.player.y + this.player.height > this.groundY - 2) {
            this.player.y = this.groundY - this.player.height;
            this.player.dy = 0;
            this.player.grounded = true;
            
            // Footsteps Logic
            this.stepTimer += dt;
            const stepInterval = Math.max(10, 30 - this.currentSpeed * 1.5); 
            if (this.stepTimer > stepInterval) {
                this.sound.playStep();
                this.stepTimer = 0;
            }

            if (Math.random() < 0.2 * dt) {
                 this.createParticles(this.player.x + 10, this.player.y + this.player.height, 1, '#443333', 'dust');
            }
        } else {
            this.player.grounded = false;
        }

        // Animation
        this.player.capeFrame += (0.1 + (this.currentSpeed * 0.01)) * dt;
        if (this.player.grounded) {
            this.player.runFrame += (0.2 + (this.currentSpeed * 0.01)) * dt;
        } else {
            this.player.runFrame = 0;
        }

        // PROGRESSION: Base speed increases slowly
        const maxBaseSpeed = 9.0;
        this.baseSpeed = Math.min(this.baseSpeed + 0.0004 * dt, maxBaseSpeed);
        
        // Score sound logic
        const oldScore = Math.floor(this.score);
        this.score += 0.1 * dt;
        const newScore = Math.floor(this.score);
        
        document.getElementById('scoreVal').innerText = newScore;
        
        if (newScore > 0 && newScore % 100 === 0 && newScore !== oldScore) {
            this.sound.playScore();
        }

        if (this.shakeIntensity > 0) this.shakeIntensity *= Math.pow(0.9, dt);
        if (this.shakeIntensity < 0.5) this.shakeIntensity = 0;

        // ============================================
        // OBSTACLES SPAWNING & LOGIC
        // ============================================
        this.spawnTimer += dt;
        const difficulty = Math.min(this.score / 250, 1); 

        const gapFramesBase = 78 - 28 * difficulty;
        const gapFrames = gapFramesBase + (Math.random() * 20 - 5);

        const minReactFrames = 35; 
        const airFrames = (2 * this.player.jumpForce) / this.gravity;
        const minMustJumpGap = airFrames + 10;

        let canSpawn = false;

        if (this.obstacles.length === 0) {
            canSpawn = this.spawnTimer >= gapFrames;
        } else {
            const last = this.obstacles[this.obstacles.length - 1];
            const neededFrames = (last.mustJump) ? minMustJumpGap : minReactFrames;
            const minDistance = this.currentSpeed * neededFrames;

            if ((this.width - last.x) >= minDistance && this.spawnTimer >= gapFrames) {
                canSpawn = true;
            }
        }

        if (canSpawn) this.trySpawnObstacle();

        // Update Obstacles Loop
        for (let i = this.obstacles.length - 1; i >= 0; i--) {
            let obs = this.obstacles[i];
            
            // 1. Move Horizontal
            obs.x -= this.currentSpeed * dt;
            obs.pulse += 0.1 * dt;

            // 2. NEW: Homing Ghost Logic (Stalker)
            // If it's a stalker, it flies towards player's Y level
            if (obs.subtype === 'stalker') {
                const dist = obs.x - this.player.x;
                // Only stalk if far enough away (gives chance to dodge at last second)
                if (dist > 150) {
                    const targetY = this.player.y + (this.player.height/2) - (obs.height/2);
                    const dy = (targetY - obs.y) * 0.05 * dt; // Smooth tracking
                    obs.y += dy;
                }
            }

            // 3. NEW: Speed Burst Logic
            // If obstacle has 'canBurst' flag and hasn't triggered yet
            // Trigger when close enough (e.g., 250px)
            if (obs.canBurst && !obs.burstTriggered) {
                const dist = obs.x - this.player.x;
                // FIX: Increased detection range slightly (300) and reduced burst intensity (1.35)
                // This makes it less punishing on mobile touch screens
                if (dist < 300 && dist > 100) {
                    obs.burstTriggered = true;
                    this.speedMultiplier = 1.35; // Was 1.6 - reduced for better playability
                    this.sound.playWhoosh();
                    this.shakeIntensity = 5; // Slight shake for impact
                    
                    // Logic: Count bursts, trigger cooldown if limit reached
                    this.burstCount++;
                    if (this.burstCount >= 2) {
                        this.burstCooldownEnd = this.score + 100;
                        this.burstCount = 0;
                    }
                }
            }

            // Collision
            let hitX = obs.x + 10;
            let hitW = obs.width - 20;
            let hitY = obs.y + 10;
            let hitH = obs.height - 15;

            if (this.player.x < hitX + hitW &&
                this.player.x + this.player.width > hitX &&
                this.player.y < hitY + hitH &&
                this.player.y + this.player.height > hitY) {
                
                this.createParticles(this.player.x + 20, this.player.y + 30, 50, '#000', 'death');
                this.shakeIntensity = 20;
                this.setState('GAMEOVER');
                document.getElementById('finalScore').innerText = Math.floor(this.score);
                this.sound.playCrash();
            }

            if (obs.x + obs.width < 0) this.obstacles.splice(i, 1);
        }

        // Particles
        for (let i = this.particles.length - 1; i >= 0; i--) {
            let p = this.particles[i];
            p.x += p.vx * dt;
            p.y += p.vy * dt;
            p.life -= 0.02 * dt;
            if (p.life <= 0) this.particles.splice(i, 1);
        }
    }

    trySpawnObstacle() {
        this.spawnTimer = 0;

        const r = Math.random();
        let type = 'tombstone';
        let mustJump = true;
        let size = 50; 
        let obsY = this.groundY - size + 5;
        let canBurst = false;

        // Determine Type
        if (this.score > 50) {
            if (r < 0.20) type = 'ghostHigh';
            else if (r < 0.40) type = 'ghostLow';
            else if (r < 0.55) type = 'stalker'; // NEW: Homing ghost
        }

        // Configure Type
        if (type === 'tombstone') {
            size = 50;
            obsY = this.groundY - size + 5;
            mustJump = true;
        } else if (type === 'ghostLow') {
            size = 40;
            obsY = this.groundY - 60 - Math.random() * 20;
            mustJump = true;
        } else if (type === 'ghostHigh') {
            size = 40;
            obsY = this.groundY - 130 - Math.random() * 40;
            mustJump = false;
        } else if (type === 'stalker') {
            size = 40;
            // Starts high or low random
            obsY = (Math.random() > 0.5) ? (this.groundY - 140) : (this.groundY - 50);
            mustJump = true; // tricky, player must react
        }

        // NEW: Probability to be a "Speed Burst" obstacle
        // Makes the game harder by accelerating right before this object
        // LIMIT: Only if cooldown period is over
        if (this.score > 100 && Math.random() < 0.4 && this.score >= this.burstCooldownEnd) {
            canBurst = true;
        }

        this.obstacles.push({
            x: this.width,
            y: obsY,
            width: size,
            height: size,
            type: (type.includes('ghost') || type === 'stalker') ? 'ghost' : 'tombstone', // visual type
            subtype: type, // logic type
            pulse: 0,
            mustJump: mustJump,
            canBurst: canBurst,       // Logic flag
            burstTriggered: false     // State flag
        });
    }

    draw() {
        this.ctx.save();
        
        if (this.shakeIntensity > 0) {
            let dx = (Math.random() - 0.5) * this.shakeIntensity;
            let dy = (Math.random() - 0.5) * this.shakeIntensity;
            this.ctx.translate(dx, dy);
        }

        // OPTIMIZATION: Use Cached Gradient
        if (this.bgGradient) {
            this.ctx.fillStyle = this.bgGradient;
            this.ctx.fillRect(0, 0, this.width, this.height);
        } else {
            // Fallback just in case
            this.ctx.fillStyle = '#1a0b2e';
            this.ctx.fillRect(0, 0, this.width, this.height);
        }

        this.ctx.shadowBlur = 40;
        this.ctx.shadowColor = '#fff';
        this.ctx.fillStyle = '#ccc';
        this.ctx.beginPath();
        this.ctx.arc(this.width - 80, 80, 40, 0, Math.PI * 2);
        this.ctx.fill();
        this.ctx.shadowBlur = 0;

        this.parallaxLayers.forEach(layer => layer.draw(this.ctx));

        this.ctx.fillStyle = '#0a0a0a';
        this.ctx.fillRect(0, this.groundY, this.width, this.height - this.groundY);
        this.ctx.fillStyle = '#1a1a1a';
        this.ctx.fillRect(0, this.groundY, this.width, 10);

        if (this.state !== 'GAMEOVER' || this.shakeIntensity > 1) {
             this.drawKnight(this.player.x, this.player.y, this.player.width, this.player.height);
        }

        this.obstacles.forEach(obs => this.drawObstacle(obs));

        this.particles.forEach(p => {
            this.ctx.globalAlpha = p.life;
            this.ctx.fillStyle = p.color;
            this.ctx.beginPath();
            if (p.type === 'death') {
                this.ctx.rect(p.x, p.y, p.size, p.size);
            } else {
                this.ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
            }
            this.ctx.fill();
        });
        this.ctx.globalAlpha = 1;
        this.ctx.shadowBlur = 0;

        // OPTIMIZATION: Use Cached Vignette Gradient
        if (this.vignetteGradient) {
            this.ctx.fillStyle = this.vignetteGradient;
            this.ctx.fillRect(0, 0, this.width, this.height);
        }

        this.ctx.restore();
    }

    drawKnight(x, y, w, h) {
        this.ctx.save();
        this.ctx.translate(x | 0, y | 0); // Optimization: Int coords

        this.ctx.fillStyle = '#2a0a0a';
        this.ctx.beginPath();
        this.ctx.moveTo(10, 10);
        for(let i=0; i<30; i++) {
            this.ctx.lineTo(10 - i*1.5, 10 + i + Math.sin(this.player.capeFrame + i*0.2)*5);
        }
        this.ctx.lineTo(10, h - 10);
        this.ctx.fill();

        this.ctx.fillStyle = '#111';
        if (this.player.grounded && (this.state === 'PLAYING' || this.state === 'MENU')) {
            let legOffset = Math.sin(this.player.runFrame) * 10;
            this.ctx.fillRect(10, h-20, 8, 20 - legOffset);
            this.ctx.fillRect(22, h-20, 8, 20 + legOffset);
        } else {
            this.ctx.fillRect(10, h-25, 8, 15);
            this.ctx.fillRect(22, h-20, 8, 20);
        }

        this.ctx.fillStyle = '#222';
        this.ctx.fillRect(10, 15, 20, 35);
        
        this.ctx.fillStyle = '#1a1a1a';
        this.ctx.fillRect(8, 0, 24, 20);
        
        this.ctx.shadowBlur = 5;
        this.ctx.shadowColor = '#00ffcc';
        this.ctx.fillStyle = '#00ffcc';
        this.ctx.fillRect(22, 6, 8, 2);
        this.ctx.shadowBlur = 0;

        this.ctx.fillStyle = '#333';
        this.ctx.fillRect(15, 20, 8, 20);

        this.ctx.restore();
    }

    drawObstacle(obs) {
        this.ctx.save();
        this.ctx.translate(obs.x | 0, obs.y | 0); // Optimization: Int coords

        if (obs.type === 'ghost') {
            this.ctx.shadowBlur = 10;
            
            // Visual diff for Stalkers (Reddish) vs Normal (Purplish)
            if (obs.subtype === 'stalker') {
                this.ctx.shadowColor = '#ff3333';
                this.ctx.fillStyle = `rgba(255, 200, 200, ${0.7 + Math.sin(obs.pulse)*0.2})`;
            } else {
                this.ctx.shadowColor = '#8a2be2';
                this.ctx.fillStyle = `rgba(200, 200, 255, ${0.7 + Math.sin(obs.pulse)*0.2})`;
            }
            
            this.ctx.beginPath();
            this.ctx.arc(20, 20, 15, Math.PI, 0);
            this.ctx.lineTo(35, 40);
            this.ctx.lineTo(27, 35);
            this.ctx.lineTo(20, 40);
            this.ctx.lineTo(13, 35);
            this.ctx.lineTo(5, 40);
            this.ctx.lineTo(5, 20);
            this.ctx.fill();

            this.ctx.fillStyle = '#000';
            this.ctx.beginPath();
            this.ctx.arc(15, 18, 3, 0, Math.PI*2);
            this.ctx.arc(25, 18, 3, 0, Math.PI*2);
            this.ctx.fill();

        } else {
            this.ctx.fillStyle = '#444';
            this.ctx.beginPath();
            this.ctx.moveTo(5, obs.height);
            this.ctx.lineTo(5, 15);
            this.ctx.arc(obs.width/2, 15, obs.width/2 - 5, Math.PI, 0);
            this.ctx.lineTo(obs.width-5, obs.height);
            this.ctx.fill();

            this.ctx.strokeStyle = '#222';
            this.ctx.lineWidth = 2;
            this.ctx.beginPath();
            this.ctx.moveTo(15, 15);
            this.ctx.lineTo(25, 25);
            this.ctx.lineTo(20, 35);
            this.ctx.stroke();

            // Highlight burst traps visually? subtle red glow
            if (obs.canBurst) {
                 this.ctx.shadowBlur = 5;
                 this.ctx.shadowColor = '#ff0000';
            } else {
                 this.ctx.shadowBlur = 10;
                 this.ctx.shadowColor = '#b30000';
            }
            
            this.ctx.fillStyle = '#b30000';
            this.ctx.fillRect(5, obs.height-5, obs.width-10, 5);
        }

        this.ctx.restore();
    }

    loop(timestamp) {
        if (!this.isTabActive) return;
        
        requestAnimationFrame(this.loop);

        if (!this.lastTime) this.lastTime = timestamp;
        const deltaTime = timestamp - this.lastTime;
        this.lastTime = timestamp;

        const dt = Math.min(deltaTime / 16.666, 3.0);

        this.update(dt);
        this.draw();
    }
}

// ==========================================
// INITIALIZATION FLOW (Fixed for Yandex Moderation)
// ==========================================
window.onload = () => {
    // 1. Prevent Context Menu (Req #2)
    document.addEventListener('contextmenu', event => event.preventDefault());

    // 2. Initialize SDK First (Req #3)
    // FIX: Check if YaGames exists before calling init (avoids ReferenceError if sdk.js is missing)
    if (typeof YaGames !== 'undefined') {
        YaGames.init()
            .then(ysdk => {
                // 3. Define Language
                let lang = 'en';
                try {
                    const code = ysdk.environment.i18n.lang;
                    if (['ru', 'be', 'kk', 'uk', 'uz'].includes(code)) {
                        lang = 'ru';
                    }
                } catch (e) {
                    console.warn('Language detection failed', e);
                }

                // 4. Create Game with SDK and Language passed in
                // Note: Translations are applied inside Game -> YandexManager constructor
                const game = new Game(ysdk, lang);

                // 5. Signal Ready ONLY after game is created
                ysdk.features.LoadingAPI.ready();
            })
            .catch(e => {
                console.error('SDK Init Failed', e);
                // Fallback for local testing (mock mode)
                const game = new Game(null, 'en');
            });
    } else {
        // SDK script failed to load or is missing (local dev environment)
        console.log('YaGames SDK not found. Launching in Offline/Mock Mode.');
        const game = new Game(null, 'en');
    }
};
</script>
</body>
</html>
